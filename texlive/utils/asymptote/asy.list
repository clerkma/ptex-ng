void drawstrokepath(picture pic=<default>, path g, pen strokepen, pen p=<default>);
real legendlinelength;
string outdirectory();
marker markthin(path g, pen p=<default>, real thin(real fraction)=<default>, filltype filltype=<default>);
bool prc(string format=<default>);
light currentlight;
pen royalblue;
real arrowdir;
filltype filltype(int type=<default>, pen fillpen=<default>, pen drawpen=<default>, void fill2(frame f, path[] g, pen fillpen));
string file(string s);
restricted int Suppress;
restricted align NoAlign;
filltype RadialShade(pen penc, pen penr);
real[] arrowbasepoints(path base, path left, path right, real default=<default>);
restricted real bp;
pen mean(pen[] p, real opacity(real[])=<default>);
pen[] mean(pen[][] palette, real opacity(real[])=<default>);
bool EndBar(picture, path, pen, marginT(path, pen))(real size=<default>);
bool EndBar(picture, path, pen, marginT(path, pen));
string[] split(string s, string delimiter=<default>);
path plus;
frame enclose(string prefix=<default>, object F, string format=<default>);
cputime cputime();
restricted real inches;
restricted pair SW;
restricted real inch;
marginT EndMargin(path, pen);
pen mediumgrey;
pen darkcyan;
real legendhskip;
void addSaveFunction(void s()());
pen olive;
restricted pen zerowinding;
pen deepmagenta;
path[] margin(path[] g, real xmargin, real ymargin);
pen mediumyellow;
slice lastcut(path p, path knife);
pen darkgreen;
string verbatim(string s);
pen heavygray;
pen darkred;
restricted pair E;
plain_bounds plain_bounds;
pen darkgray;
frame orientation(frame);
pen salmon;
pen mediummagenta;
pair arcdir(path p, real L);
pen mediumcyan;
pen Pentype(int n);
triple gettriple(string name=<default>, triple default=<default>, string prompt=<default>, bool store=<default>);
pen Yellow;
picture legenditem(Legend legenditem, real linelength);
restricted real cm;
pen mediumgreen;
pen heavygreen;
bool EndArrow(picture, path, pen, marginT(path, pen))(arrowhead arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>);
bool EndArrow(picture, path, pen, marginT(path, pen));
pen dashdotted;
pen deepblue;
string graphicscale(real x);
pen mediumblue;
restricted transform invert;
restricted pair NNW;
restricted pair SE;
coord[] maxcoords(coord[] in, bool operator <=(coord, coord));
pen thick(pen p=<default>);
picture arrow2(arrowhead arrowhead=<default>, path g, pen p=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, marginT margin(path, pen)=<default>);
pen mediumred;
marginT EndDotMargin(path, pen);
void filloutside(picture pic=<default>, path[] g, pen p=<default>, bool copy=<default>);
void filloutside(frame f, path[] g, pen p=<default>, bool copy=<default>);
marginT BeginDotMargin(path, pen);
marker[] Mark;
marker Mark(int n);
projection projection(triple camera, triple up=<default>, triple target=<default>, triple normal=<default>, real zoom=<default>, real angle=<default>, pair viewportshift=<default>, bool showtarget=<default>, bool autoadjust=<default>, bool center=<default>, transformation projector(triple camera, triple up, triple target));
pen darkolive;
pen Dotted;
pen Dotted(pen p=<default>);
string math(string s);
transform fixedscaling(picture pic=<default>, pair min, pair max, pen p=<default>, bool warn=<default>);
pen Symbol(string series=<default>, string shape=<default>);
int count;
string ask(string prompt);
frame[] fit2(picture[] pictures, picture all);
path circle(pair c, real r);
restricted pen beveljoin;
pen orange;
pen green;
real legendmargin;
bool None(picture, path, pen, marginT(path, pen));
restricted file stdin;
real calculateScaling(string dir, coord[] coords, real size, bool warn=<default>);
real calculateScaling(string dir, coord[] m, coord[] M, real size, bool warn=<default>);
real arcarrowsize(pen p=<default>);
restricted path unitcircle;
arrowhead DefaultHead;
pen white;
restricted position EndPoint;
transform Rotate(transform)(pair z);
transform Rotate(transform t);
Legend Legend(string label, pen plabel=<default>, pen p=<default>, frame mark=<default>, bool above=<default>);
void exitfunction();
string cputimeformat;
pair arcpoint(path p, real L);
bool interior(int windingnumber, pen fillrule);
pen fuchsia;
pen brown;
path ellipse(frame dest, frame src=<default>, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
path ellipse(frame f, Label L, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
path ellipse(pair c, real a, real b);
void bar(picture pic, pair a, pair d, pen p=<default>);
picture bar(pair a, pair d, pen p=<default>);
frame dotframe;
frame dotframe(pen p=<default>, filltype filltype=<default>);
pen deepcyan;
pen dotted;
void copyPairOrTriple(pairOrTriple dest, pairOrTriple src);
int debuggerlines;
frame bbox(picture pic=<default>, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>);
pair reldir(path p, real l);
pen pink;
pen TimesRoman(string series=<default>, string shape=<default>);
pen palemagenta;
restricted int mantissaBits;
pen lightolive;
void fillbox(frame dest, path g, pen p=<default>, filltype filltype=<default>, bool above=<default>);
path arrowbase(path r, pair y, real t, real size);
pen[] monoPen;
bool CW;
pen Cyan;
bool BeginArcArrow(picture, path, pen, marginT(path, pen))(arrowhead arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>);
bool BeginArcArrow(picture, path, pen, marginT(path, pen));
marginT EndPenMargin(path, pen);
restricted pair NNE;
bool Bars(picture, path, pen, marginT(path, pen))(real size=<default>);
bool Bars(picture, path, pen, marginT(path, pen));
restricted pen roundjoin;
pen lightgray;
restricted position MidPoint;
string Embed(string name, string text=<default>, string options=<default>, real width=<default>, real height=<default>);
pen deepgrey;
pen lightyellow;
marginT Margin(path, pen)(real begin, real end=<default>);
marginT Margin(path, pen);
restricted side NoSide;
restricted file stdout;
void mapArray(string From, string To);
frame Seascape(frame f);
restricted pair up;
pen ZapfChancery(string series=<default>, string shape=<default>);
restricted pair left;
bool prconly(string format=<default>);
pen deepgreen;
pen lightmagenta;
real bracedefaultratio;
transform Scale(transform t);
string getstring(string name=<default>, string default=<default>, string prompt=<default>, bool store=<default>);
marginT DotMargins(path, pen);
path[] MarkPath;
pen deepgray;
string defaultformat(int n, string trailingzero=<default>, bool fixed=<default>, bool signed=<default>);
string defaultformat;
pen lightcyan;
pen paleblue;
frame align(frame f, pair align);
path[] align(path[] g, transform t=<default>, pair position, pair align, pen p=<default>);
object align(object F, pair align);
bool BeginArrow(picture, path, pen, marginT(path, pen))(arrowhead arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>);
bool BeginArrow(picture, path, pen, marginT(path, pen));
transform scaleless(transform t);
pen RGB(int r, int g, int b);
pen thin();
real arcarrowangle;
void restoredefaults();
pen longdashdotted;
void usepackage(string s, string options=<default>);
pen dashed;
string TeXify(string s);
string graphic(string name, string options=<default>);
frame Portrait(frame f);
real braceinnerangle;
guide operator ---(... guide[]);
string outprefix(string prefix=<default>);
object object(Label L, path e(frame dest, frame src=<default>, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>), real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
object object(Label L);
object object(frame f);
void drawarrow2(frame f, arrowhead arrowhead=<default>, path g, pen p=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, marginT margin(path, pen)=<default>);
restricted int JOIN_IN;
void addArrow(picture pic, arrowhead arrowhead, path g, pen p, real size, real angle, filltype filltype, real position);
real barfactor;
picture arrow(arrowhead arrowhead=<default>, path g, pen p=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>, bool forwards=<default>, marginT margin(path, pen)=<default>, bool center=<default>);
void arrow(picture pic=<default>, Label L=<default>, pair b, pair dir, real length=<default>, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>);
void unitsize(picture pic=<default>, real x, real y=<default>, real z=<default>);
pen lightgreen;
restricted transform zeroTransform;
pair relative(picture pic=<default>, pair z);
void endl(file file);
void usersetting();
bool prc0(string format=<default>);
frame pack(pair align=<default>, ... object[] inset);
void marknodes(picture pic=<default>, frame f, path g);
real reltime(path p, real l);
pair rectify(pair dir);
arrowhead TeXHead;
real labelmargin;
real labelmargin(pen p=<default>);
pen lightblue;
real bracemidangle;
restricted path unitsquare;
pen cyan;
pen grey;
transform rotation(transform t);
restricted pair W;
pen magenta;
restricted pair WSW;
restricted pen nobasealign;
bool debugging;
void shipout(string prefix=<default>, frame f, string format=<default>, bool wait=<default>, bool view=<default>, string options=<default>, string script=<default>, light light=<default>, projection P=<default>, transform t=<default>);
void shipout(string prefix=<default>, picture pic=<default>, frame orientation(frame)=<default>, string format=<default>, bool wait=<default>, bool view=<default>, string options=<default>, string script=<default>, light light=<default>, projection P=<default>);
frame Landscape(frame f);
real camerafactor;
pen lightred;
path trim(path g, real begin, real end=<default>);
marginT DotMargin(path, pen)(real begin, real end=<default>);
marginT DotMargin(path, pen);
pen squarepen;
pen deepyellow;
real barsize(pen p=<default>);
void begin(picture pic=<default>, string name, string id=<default>, bool visible=<default>);
pen Bookman(string series=<default>, string shape=<default>);
frame[] fit(string prefix=<default>, picture[] pictures, string format=<default>, bool view=<default>, string options=<default>, string script=<default>, projection P=<default>);
path box(frame dest, frame src=<default>, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
path box(frame f, Label L, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
path box(pair a, pair b);
pen AvantGarde(string series=<default>, string shape=<default>);
restricted real circleprecision;
pen Black;
pen Pen(int n);
restricted pair ENE;
pen Courier(string series=<default>, string shape=<default>);
void makedraw(frame f, path g, pen p, int depth=<default>);
restricted pair down;
path arc(pair c, real r, real angle1, real angle2);
path arc(pair c, explicit pair z1, explicit pair z2, bool direction=<default>);
path arc(pair c, real r, real angle1, real angle2, bool direction);
restricted pair right;
string outformat(string format=<default>);
filltype Fill;
filltype Fill(real xmargin=<default>, real ymargin=<default>, pen p=<default>);
pen Palatino(string series=<default>, string shape=<default>);
pair[] intersectionpoints(path p, path q, real fuzz=<default>);
pair[] intersectionpoints(explicit path[] p, explicit path[] q, real fuzz=<default>);
void savedefaults()();
bool MidArrow(picture, path, pen, marginT(path, pen))(arrowhead arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>);
bool MidArrow(picture, path, pen, marginT(path, pen));
real expansionfactor;
restricted position BeginPoint;
real arrowhookfactor;
bool finite(real x);
bool finite(pair z);
bool finite(triple v);
filltype UnFill(real xmargin=<default>, real ymargin=<default>);
filltype UnFill;
restricted pair I;
restricted pair SSW;
transform Slant(transform t);
pair intersectionpoint(path p, path q, real fuzz=<default>);
real getreal(string name=<default>, real default=<default>, string prompt=<default>, bool store=<default>);
pen darkbrown;
int sourceline(string file, string text);
real RELEASE;
void updatefunction();
bool implicitshipout;
void buildRestoreDefaults()();
path[] operator ^^(path p, path q);
path[] operator ^^(explicit path[] p, path q);
path[] operator ^^(path p, explicit path[] q);
path[] operator ^^(explicit path[] p, explicit path[] q);
real arrow2sizelimit;
object embed3(string, frame, string, string, string, light, projection);
bool ArcArrows(picture, path, pen, marginT(path, pen));
bool ArcArrows(picture, path, pen, marginT(path, pen))(arrowhead arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>);
filltype FillDraw;
filltype FillDraw(real xmargin=<default>, real ymargin=<default>, pen fillpen=<default>, pen drawpen=<default>);
Label Label(string s=<default>, string size=<default>, align align=<default>, pen p=<default>, transform embed(transform)=<default>, filltype filltype=<default>);
Label Label(string s, string size=<default>, pair position, align align=<default>, pen p=<default>, transform embed(transform)=<default>, filltype filltype=<default>);
Label Label(Label L, align align=<default>, pen p=<default>, transform embed(transform)=<default>, filltype filltype=<default>);
Label Label(Label L, pair position, align align=<default>, pen p=<default>, transform embed(transform)=<default>, filltype filltype=<default>);
Label Label(string s, string size=<default>, explicit position position, align align=<default>, pen p=<default>, transform embed(transform)=<default>, filltype filltype=<default>);
Label Label;
Label Label(Label L, explicit position position, align align=<default>, pen p=<default>, transform embed(transform)=<default>, filltype filltype=<default>);
Label Label(explicit pair position, align align=<default>, pen p=<default>, transform embed(transform)=<default>, filltype filltype=<default>);
void pause(string w=<default>);
restricted int ocgindex;
pen springgreen;
pen heavygrey;
void markuniform(picture pic=<default>, frame f, path g)(pair z(real t), real a, real b, int n);
void markuniform(picture pic=<default>, frame f, path g)(bool centered=<default>, int n, bool rotated=<default>);
real circlescale;
bool ignore;
pen darkblue;
projection centered(projection P, picture pic=<default>);
restricted int JOIN_OUT;
projection currentprojection;
real arrowsizelimit;
pair endpoint(path p);
arrowhead HookHead;
arrowhead HookHead(real dir=<default>, real barb=<default>);
real[] concat(... real[][]);
marker[] concat(... marker[][]);
Label[] concat(... Label[][]);
bool3[] concat(... bool3[][]);
pair[] concat(... pair[][]);
pen[] concat(... pen[][]);
path[] concat(... path[][]);
int[] concat(... int[][]);
object[] concat(... object[][]);
void()()[] concat(... void()()[][]);
string[] concat(... string[][]);
Legend[] concat(... Legend[][]);
picture[] concat(... picture[][]);
triple[] concat(... triple[][]);
frame[] concat(... frame[][]);
guide[] concat(... guide[][]);
bool[] concat(... bool[][]);
coord[] concat(... coord[][]);
slice firstcut(path p, path knife);
bool ArcArrow(picture, path, pen, marginT(path, pen));
bool ArcArrow(picture, path, pen, marginT(path, pen))(arrowhead arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>);
frame UpsideDown(frame f);
pair viewportmargin;
pen nullpen;
void progress(bool3 init=<default>);
void save()();
real dotfactor;
pen palecyan;
node node(void d(frame f, transform t, transform T, pair lb, pair rt), string key=<default>);
marginT BeginMargin(path, pen);
path buildcycle(... path[] p);
void activatequote(picture pic=<default>);
restricted int undefined;
restricted pen roundcap;
void buildRestoreThunk()();
void overloadedMessage(file file);
frame currentpatterns;
real arrowfactor;
pen heavyred;
pen black;
void Draw(picture pic=<default>, explicit path[] g, pen p=<default>);
filltype Draw;
filltype Draw(real xmargin=<default>, real ymargin=<default>, pen p=<default>);
void Draw(picture pic=<default>, path g, pen p=<default>);
void tab(file file);
marker marker(frame f=<default>, void markroutine(picture pic=<default>, frame f, path g)=<default>, bool above=<default>);
marker marker(path[] g, void markroutine(picture pic=<default>, frame f, path g)=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
bool CCW;
void usetypescript(string s, string encoding=<default>);
path randompath(int n, bool cumulate=<default>, guide join(... guide[])=<default>);
void()()[] array(int n, void value()(), int depth=<default>);
bool[] array(int n, bool value, int depth=<default>);
Legend[] array(int n, Legend value, int depth=<default>);
picture[] array(int n, picture value, int depth=<default>);
string[] array(int n, string value, int depth=<default>);
pair[][] array(int n, pair[] value, int depth=<default>);
marker[] array(int n, marker value, int depth=<default>);
Label[] array(int n, Label value, int depth=<default>);
real[][] array(int n, real[] value, int depth=<default>);
real[] array(int n, real value, int depth=<default>);
triple[] array(int n, triple value, int depth=<default>);
path[] array(int n, path value, int depth=<default>);
frame[] array(int n, frame value, int depth=<default>);
coord[] array(int n, coord value, int depth=<default>);
pen[][] array(int n, pen[] value, int depth=<default>);
int[] array(int n, int value, int depth=<default>);
string[][] array(int n, string[] value, int depth=<default>);
pair[] array(int n, pair value, int depth=<default>);
bool3[] array(int n, bool3 value, int depth=<default>);
guide[] array(int n, guide value, int depth=<default>);
object[] array(int n, object value, int depth=<default>);
pen[] array(int n, pen value, int depth=<default>);
string[] array(string s);
real[] uniform(real a, real b, int n);
pair viewportsize;
void drawarrow(frame f, arrowhead arrowhead=<default>, path g, pen p=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>, bool forwards=<default>, marginT margin(path, pen)=<default>, bool center=<default>);
picture currentpicture;
pen palegreen;
hsv hsv(real h, real s, real v);
hsv hsv(pen p);
restricted pair N;
real dotsize(pen p=<default>);
restricted real pt;
settings settings;
restricted int MoveQuiet;
restricted pair WNW;
pen palegray;
restricted pen miterjoin;
arrowhead SimpleHead;
real arrowangle;
path diamond;
real arcarrowfactor;
restricted real mm;
pen heavyblue;
filltype dotfilltype;
plain plain;
int getint(string name=<default>, int default=<default>, string prompt=<default>, bool store=<default>);
int bitreverse(int a, int bits);
int popcount(int a);
int CLZ(int a);
int NOT(int a);
int XOR(int a, int b);
int OR(int a, int b);
real[][] scale3(real s);
int AND(int a, int b);
real[] cubicroots(real a, real b, real c, real d);
void attach(picture dest=<default>, frame src, pair position, pair align, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void attach(picture dest=<default>, frame src, pair position=<default>, bool group=<default>, filltype filltype=<default>, bool above=<default>);
real[] quadraticroots(real a, real b, real c);
pair[] quadraticroots(explicit pair a, explicit pair b, explicit pair c);
path[] strokepath(path g, pen p=<default>);
real erf(real x);
real Yn(int n, real x);
real Jn(int n, real x);
light light(explicit light light);
light light(pen diffuse=<default>, pen specular=<default>, pen background=<default>, real x, real y, real z);
light light(pen diffuse=<default>, pen specular=<default>, pen background=<default>, real specularfactor=<default>, ... triple[] position);
light light(pen[] diffuse, pen[] specular=<default>, pen background=<default>, real specularfactor=<default>, triple[] position);
real remainder(real x, real y);
int choose(int n, int k);
real hypot(real x, real y);
int Round(real x);
int Ceil(real x);
marginT BeginPenMargin(path, pen);
int round(real x);
int floor(real x);
restricted pen extendcap;
int ceil(real x);
int rand(int a=<default>, int b=<default>);
int sgn(real x);
int quotient(int x, int y);
path3 path3(triple[] pre, triple[] point, triple[] post, bool[] straight, bool cyclic);
real incircle(pair a, pair b, pair c, pair d);
real atan2(real y, real x);
bool inside(explicit path[] g, pair z, pen fillrule=<default>);
bool inside(path g, pair z, pen fillrule=<default>);
int inside(path p, path q, pen fillrule=<default>);
pair inside(path p, pen fillrule=<default>);
real erfc(real x);
int windingnumber(path[] p, pair z);
real relativedistance(real theta, real phi, real t, bool atleast);
string[] file3;
real[] maxtimes(path p);
real[] maxtimes(path3 p);
real[] mintimes(path p);
real[] mintimes(path3 p);
pair maxAfterTransform(transform t, path[] p);
pair minAfterTransform(transform t, path[] p);
pair extension(pair p, pair q, pair p, pair q);
string mapArrayString(string From, string To);
real[][] intersections(path p, path q, real fuzz=<default>);
real[] intersections(path p, explicit pair a, explicit pair b, real fuzz=<default>);
real[][] intersections(path3 p, path3 q, real fuzz=<default>);
real[][] intersections(path3 p, triple[][] p, real fuzz=<default>);
real[] intersect(path p, path q, real fuzz=<default>);
real[] intersect(path3 p, path3 q, real fuzz=<default>);
real[] intersect(path3 p, triple[][] p, real fuzz=<default>);
real dirtime(path p, pair z);
real arctime(path p, real l);
real arctime(path3 p, real dval);
position Relative(real position);
side Relative(explicit pair align);
pair truepoint(picture pic=<default>, pair dir, bool user=<default>);
marginT Margins(path, pen);
real arclength(path p);
real arclength(pair z0, pair c0, pair c1, pair z1);
real arclength(path3 p);
real arclength(triple z0, triple c0, triple c1, triple z1);
bool piecewisestraight(path p);
bool piecewisestraight(path3 p);
path nurb(pair z0, pair z1, pair z2, pair z3, real w0, real w1, real w2, real w3, int m);
path subpath(path p, int a, int b);
path subpath(path p, real a, real b);
path3 subpath(path3 p, int a, int b);
path3 subpath(path3 p, real a, real b);
real radius(path p, real t);
real radius(path3 p, real t);
real radius(triple z0, triple c0, triple c1, triple z1, real t);
pair accel(path p, int t, int sign=<default>);
pair accel(path p, real t);
triple accel(path3 p, int t, int sign=<default>);
triple accel(path3 p, real t);
pair precontrol(path p, int t);
pair precontrol(path p, real t);
triple precontrol(path3 p, int t);
triple precontrol(path3 p, real t);
string defaultfilename;
real longitude(triple v, bool warn=<default>);
filltype NoFill;
real colatitude(triple v, bool warn=<default>);
marker nomarker;
pair beginpoint(path p);
real azimuth(triple v, bool warn=<default>);
real polar(triple v, bool warn=<default>);
real zpart(triple v);
pair bezierPPP(pair a, pair b, pair c, pair d);
triple bezierPPP(triple a, triple b, triple c, triple d);
restricted pair SSE;
pair bezierP(pair a, pair b, pair c, pair d, real t);
triple bezierP(triple a, triple b, triple c, triple d, real t);
pair realmult(pair z, pair w);
triple realmult(triple u, triple v);
int Floor(real x);
pair gamma(explicit pair z);
real gamma(real x);
pair expi(real angle);
triple expi(real polar, real azimuth);
pair dir(real degrees);
pair dir(explicit pair z);
triple dir(explicit triple z);
triple dir(real colatitude, real longitude);
pair dir(path p, int t, int sign=<default>, bool normalize=<default>);
pair dir(path p, real t, bool normalize=<default>);
triple dir(path3 p, int t, int sign=<default>, bool normalize=<default>);
triple dir(path3 p, real t, bool normalize=<default>);
pair dir(path p);
pair dir(path p, path q);
real aTan(real x);
real aCos(real x);
real aSin(real x);
real arrowsize(pen p=<default>);
real Tan(real deg);
real Cos(real deg);
frame legend(picture pic=<default>, int perline=<default>, real xmargin=<default>, real ymargin=<default>, real linelength=<default>, real hskip=<default>, real vskip=<default>, real maxwidth=<default>, real maxheight=<default>, bool hstretch=<default>, bool vstretch=<default>, pen p=<default>);
picture legend(Legend[] Legend, int perline=<default>, real linelength, real hskip, real vskip, real maxwidth=<default>, real maxheight=<default>, bool hstretch=<default>, bool vstretch=<default>);
real Degrees(real radians);
frame pad(picture pic=<default>, real xsize=<default>, real ysize=<default>, filltype filltype=<default>);
real radians(real degrees);
real angle(pair z, bool warn=<default>);
real angle(transform t);
restricted side Center;
real ypart(pair z);
real ypart(triple v);
real xpart(pair z);
real xpart(triple v);
int seconds(string t=<default>, string format=<default>);
pen rgba(real[] a);
real[] rgba(pen p);
string time(string format=<default>);
string time(int seconds, string format=<default>);
string string(int x);
string string(real x, int digits=<default>);
int ascii(string s);
restricted side RightSide;
string replace(string s, string[][] translate);
string replace(string s, string before, string after);
pen lightgrey;
string upcase(string s);
pen mediumgray;
string downcase(string s);
string substr(string s, int pos, int n=<default>);
string insert(string s, int pos, string t);
int rfind(string s, string t, int pos=<default>);
void purge(int divisor=<default>);
int animate(string args=<default>, string file=<default>, string format=<default>);
int convert(string args=<default>, string file=<default>, string format=<default>);
restricted real sqrtEpsilon;
string stripextension(string s);
string stripfile(string s);
string stripdirectory(string s);
void warning(string s, string t, bool position=<default>);
restricted pair S;
real abs2(pair z);
real abs2(triple v);
void nowarn(string s);
void warn(string s);
void breakpoints();
string locatefile(string file, bool full=<default>);
void breakpoint(code s=<default>);
void atbreakpoint(string f(string, int, int, code));
string phantom(string s);
void atexit(void f());
void atexit()();
void atupdate(void f());
void atupdate()();
string outname();
string mktemp(string s);
int rename(string from, string to);
real arrowbarb;
pen yellow;
int delete(string s);
void seekeof(file f);
pen heavymagenta;
marginT PenMargins(path, pen);
void newl(file file);
void seek(file f, int pos);
bool Arrows(picture, path, pen, marginT(path, pen));
bool Arrows(picture, path, pen, marginT(path, pen))(arrowhead arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>);
int tell(file f);
void DOSendl(file file);
string debugger(string file, int line, int column, code s=<default>);
string getc(file f);
void flush(file f);
pen blue;
restricted pen evenodd;
int precision(file f=<default>, int digits=<default>);
void close(file f);
void clear(file f);
void clear(string file, int line);
void clear();
void clear(string file, string text);
bool Bar(picture, path, pen, marginT(path, pen))(real size=<default>);
bool Bar(picture, path, pen, marginT(path, pen));
void unfill(picture pic=<default>, path[] g, bool copy=<default>);
void unfill(frame f, path[] g, bool copy=<default>);
bool eol(file f);
bool eof(file f);
pen paleyellow;
file output(string name=<default>, bool update=<default>, string comment=<default>, string mode=<default>);
file input(string name=<default>, bool check=<default>, string comment=<default>, string mode=<default>);
pair bezierPP(pair a, pair b, pair c, pair d, real t);
triple bezierPP(triple a, triple b, triple c, triple d, real t);
real[] _projection();
triple maxbezier(triple[][] p, triple b);
triple minbezier(triple[][] p, triple b);
real legendvskip;
pen darkmagenta;
real change2(triple[][] a);
restricted pair NW;
real norm(real[] a);
real norm(real[][] a);
real norm(triple[][] a);
int[][] triangulate(pair[] z);
pair[] fft(pair[] a, int sign=<default>);
pair[][] fft(pair[][] a, int sign=<default>);
pair[][][] fft(pair[][][] a, int sign=<default>);
real simpson(real f(real), real a, real b, real acc=<default>, real dxmax=<default>);
pen[] colorPen;
real _findroot(real f(real), real a, real b, real tolerance, real fa, real fb);
real newton(int iterations=<default>, real f(real), real fprime(real), real x, bool verbose=<default>);
real newton(int iterations=<default>, real f(real), real fprime(real), real x1, real x2, bool verbose=<default>);
real[] tridiagonal(real[] a, real[] b, real[] c, real[] f);
void filldraw(picture pic=<default>, path[] g, pen fillpen=<default>, pen drawpen=<default>);
void filldraw(frame f, path[] g, pen fillpen=<default>, pen drawpen=<default>);
real dot(real[] a, real[] b);
pair dot(pair[] a, pair[] b);
real dot(explicit pair z, explicit pair w);
real dot(triple u, triple v);
marker dot(pen p=<default>, filltype filltype=<default>);
void dot(picture pic=<default>, pair z, pen p=<default>, filltype filltype=<default>);
void dot(picture pic=<default>, Label L, pair z, align align=<default>, string format=<default>, pen p=<default>, filltype filltype=<default>);
void dot(frame f, pair z, pen p=<default>, filltype filltype=<default>);
void dot(picture pic=<default>, Label L, pen p=<default>, filltype filltype=<default>);
void dot(picture pic=<default>, Label[] L=<default>, explicit path g, align align=<default>, string format=<default>, pen p=<default>, filltype filltype=<default>);
void dot(picture pic=<default>, path[] g, pen p=<default>, filltype filltype=<default>);
marker dot;
void dot(picture pic=<default>, Label[] L=<default>, pair[] z, align align=<default>, string format=<default>, pen p=<default>, filltype filltype=<default>);
restricted pair ESE;
pair project(triple v, real[][] t);
real[][] AtA(real[][] a);
real[] solve(real[][] a, real[] b, bool warn=<default>);
real[][] solve(real[][] a, real[][] b, bool warn=<default>);
scaleT scaleT(real T(real), real Tinv(real), bool logarithmic=<default>, bool automin=<default>, bool automax=<default>);
string baseline(string s, string template=<default>);
int[] findall(bool[] a);
bool BeginBar(picture, path, pen, marginT(path, pen))(real size=<default>);
bool BeginBar(picture, path, pen, marginT(path, pen));
triple perp(triple v, triple u);
int find(bool[] a, int n=<default>);
int find(string s, string t, int pos=<default>);
real degrees(pair z, bool warn=<default>);
real degrees(real radians);
bool[] operator !(bool[] a);
bool operator !(bool b);
int[] sequence(int n);
pen[][] sequence(pen[] f(int), int n);
int[] sequence(int f(int), int n);
string[][] sequence(string[] f(int), int n);
pair[] sequence(pair f(int), int n);
bool3[] sequence(bool3 f(int), int n);
int[] sequence(int n, int m, int skip);
guide[] sequence(guide f(int), int n);
object[] sequence(object f(int), int n);
pen[] sequence(pen f(int), int n);
void()()[] sequence(void f()()(int), int n);
bool[] sequence(bool f(int), int n);
Legend[] sequence(Legend f(int), int n);
picture[] sequence(picture f(int), int n);
string[] sequence(string f(int), int n);
pair[][] sequence(pair[] f(int), int n);
marker[] sequence(marker f(int), int n);
Label[] sequence(Label f(int), int n);
real[][] sequence(real[] f(int), int n);
real[] sequence(real f(int), int n);
int[] sequence(int n, int m);
triple[] sequence(triple f(int), int n);
path[] sequence(path f(int), int n);
frame[] sequence(frame f(int), int n);
coord[] sequence(coord f(int), int n);
int[] complement(int[] a, int n);
path[] complement(frame f, path[] g);
void saveline(string name, string value, bool store=<default>);
string readline(string prompt=<default>, string name=<default>, bool tabcompletion=<default>);
real unitrand();
string[] history(string name, int n=<default>);
string[] history(int n=<default>);
path[] _strokepath(path g, pen p=<default>);
path[][] textpath(string[] s, pen[] p);
marginT NoMargin(path, pen);
marginT NoMargin(path, pen)();
path[][] _texpath(string[] s, pen[] p);
restricted int SuppressQuiet;
real[] texsize(string s, pen p=<default>);
bool labels(frame f);
slice cut(path p, path knife, int n);
bool is3D(frame f);
bool is3D(string format=<default>);
transformation transformation(real[][] modelview);
transformation transformation(real[][] modelview, real[][] projection);
pair maxratio(frame f);
pair maxratio(triple[][] p, pair b);
pair maxratio(path3 g);
pair minratio(frame f);
pair minratio(triple[][] p, pair b);
pair minratio(path3 g);
triple size3(frame f);
void size3(picture pic=<default>, real x, real y=<default>, real z=<default>, bool keepAspect=<default>);
triple max3(frame f);
triple max3(pen p);
int[] MarkFillable;
pair unit(pair z);
triple unit(triple v);
triple min3(frame f);
triple min3(pen p);
void drawpixel(frame f, triple v, pen p, real width=<default>);
pair[] pairs(real[] x, real[] y);
void eval(code s, bool embedded=<default>);
void eval(string s, bool embedded=<default>);
bool Arrow(picture, path, pen, marginT(path, pen))(arrowhead arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>);
bool Arrow(picture, path, pen, marginT(path, pen));
void drawTube(frame f, triple[] g, real width, pen[] p, real opacity, real shininess, real metallic, real fresnel0, triple min, triple max, bool core=<default>);
void drawDisk(frame f, real[][] t, pen[] p, real opacity, real shininess, real metallic, real fresnel0);
void stop(string file, int line, code s=<default>);
void stop(string file, string text, code s=<default>);
void drawCylinder(frame f, real[][] t, pen[] p, real opacity, real shininess, real metallic, real fresnel0, bool core=<default>);
real insphere(triple a, triple b, triple c, triple d, triple e);
void drawSphere(frame f, real[][] t, bool half=<default>, pen[] p, real opacity, real shininess, real metallic, real fresnel0, int type);
string[] spinner;
real[] times(path p, real x, real fuzz=<default>);
real[] times(path p, explicit pair z, real fuzz=<default>);
void drawbeziertriangle(frame f, triple[][] p, triple center, bool straight, pen[] p, real opacity, real shininess, real metallic, real fresnel0, pen[] colors, int interaction, int digits, bool primitive=<default>);
void draw(frame f, triple[][] p, triple center, bool straight, pen[] p, real opacity, real shininess, real metallic, real fresnel0, pen[] colors, int interaction, int digits, bool primitive=<default>);
void draw(frame f, triple[] p, real[] knot, real[] weights=<default>, pen p);
void draw(frame f, triple[][] p, real[] uknot, real[] vknot, real[][] weights=<default>, pen[] p, real opacity, real shininess, real metallic, real fresnel0, pen[] colors);
void draw(frame f, triple[] v, int[][] vi, triple center=<default>, triple[] n, int[][] ni, pen[] p, real opacity, real shininess, real metallic, real fresnel0, pen[] c=<default>, int[][] ci=<default>, int interaction);
void draw(picture pic=<default>, path[] g, pen fillrule=<default>, pen[] p);
void draw(picture pic=<default>, Label L=<default>, path g, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool bar(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, Label legend=<default>, marker marker=<default>);
void draw(pair origin, picture pic=<default>, Label L=<default>, path g, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool bar(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, Label legend=<default>, marker marker=<default>);
void draw(frame f, explicit path[] g, pen p=<default>);
void draw(picture pic=<default>, guide[] g, pen p=<default>, Label legend=<default>, marker marker=<default>);
void draw(pair origin, picture pic=<default>, guide[] g, pen p=<default>, Label legend=<default>, marker marker=<default>);
void draw(frame f, path g, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen)));
object draw(picture pic=<default>, Label L, path e(frame dest, frame src=<default>, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>), real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
void draw(picture pic=<default>, explicit path[] g, pen p=<default>, Label legend=<default>, marker marker=<default>);
void draw(pair origin, picture pic=<default>, explicit path[] g, pen p=<default>, Label legend=<default>, marker marker=<default>);
void draw(frame f, guide[] g, pen p=<default>);
void draw(frame f, path g, pen p=<default>);
object draw(picture pic=<default>, Label L, path e(frame dest, frame src=<default>, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>), pair position, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
void deconstruct(frame f, frame preamble=<default>, transform t=<default>);
void deconstruct(picture pic=<default>);
void shipout3(string prefix, frame f, string format=<default>, real width, real height, real angle, real zoom, triple m, triple m, pair shift, pair margin, real[][] t, real[][] tup, real[] background, triple[] lights, real[][] diffuse, real[][] specular, bool view=<default>);
void shipout3(string prefix, frame f, string format=<default>);
int CTZ(int a);
void _shipout(string prefix=<default>, frame f, frame preamble=<default>, string format=<default>, bool wait=<default>, bool view=<default>, transform t=<default>);
void asy(string format, bool overwrite=<default>, ... string[] s);
bool latex();
string nativeformat();
path unstraighten(path p);
path3 unstraighten(path3 p);
void _image(frame f, real[][] data, pair initial, pair final, pen[] palette=<default>, transform t=<default>, bool copy=<default>, bool antialias=<default>);
void _image(frame f, pen[][] data, pair initial, pair final, transform t=<default>, bool copy=<default>, bool antialias=<default>);
void _image(frame f, pen f(int, int), int width, int height, pair initial, pair final, transform t=<default>, bool antialias=<default>);
void layer(frame f);
void layer(picture pic=<default>);
void texreset();
void _labelpath(frame f, string s, string size, path g, string justify, pair offset, pen p);
real arrowtexfactor;
void comma(file file);
void deletepreamble();
version version;
void texpreamble(string s);
void javascript(frame f, string s);
void javascript(picture pic=<default>, string s);
real braceouterangle;
void tex(frame f, string s);
void tex(frame f, string s, pair min, pair max);
void tex(picture pic=<default>, string s, pair min, pair max);
void tex(picture pic=<default>, string s);
void prepend(frame dest, frame src);
void add(frame dest, frame src);
void add(picture dest, picture src, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void add(picture pic=<default>, void d(frame f, real[][] t, picture pic, projection P), bool exact=<default>);
void add(picture pic=<default>, void d(picture, real[][]), bool exact=<default>);
void add(picture dest, picture src, pair position, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void add(picture dest=<default>, object F, pair position=<default>, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void add(picture pic=<default>, Label L);
void add(frame dest, frame src, filltype filltype, bool above=<default>);
void add(frame dest, frame src, bool group, filltype filltype=<default>, bool above=<default>);
void add(frame f, transform t=<default>, Label L);
void add(frame dest, frame src, pair position, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void add(picture dest=<default>, frame src, pair position=<default>, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void add(picture pic=<default>, void d(frame f, transform t), bool exact=<default>);
void add(picture pic=<default>, void d(picture, transform), bool exact=<default>);
void add(picture src, pair position, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void add(picture dest=<default>, frame src, pair position, pair align, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void add(frame dest, frame src, pair position, pair align, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void add(picture src, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void beep();
void endTransform(frame f);
void beginTransform(frame f, string geometry=<default>, string color=<default>, real duration);
void endgroup3(frame f);
void _begingroup3(frame f, string name, real compression, real granularity, bool closed, bool tessellate, bool dobreak, bool nobreak, triple center, int interaction);
void endgroup(frame f);
void endgroup(picture pic=<default>);
void begingroup(frame f);
void begingroup(picture pic=<default>);
bool MidArcArrow(picture, path, pen, marginT(path, pen))(arrowhead arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>);
bool MidArcArrow(picture, path, pen, marginT(path, pen));
void grestore(frame f);
void beginclip(frame f, path[] g, bool stroke=<default>, pen fillrule=<default>, bool copy=<default>);
void beginclip(picture pic=<default>, path[] g, bool stroke=<default>, pen fillrule=<default>, bool copy=<default>);
pen palegrey;
void clip(frame f, path[] g, bool stroke=<default>, pen fillrule=<default>, bool copy=<default>);
void clip(picture pic=<default>, path[] g, bool stroke=<default>, pen fillrule=<default>, bool copy=<default>);
restricted int Allow;
real determinant(real[][] a);
void functionshade(frame f, path[] g, bool stroke=<default>, pen fillrule=<default>, string shader=<default>, bool copy=<default>);
void functionshade(picture pic=<default>, path[] g, bool stroke=<default>, pen fillrule=<default>, string shader, bool copy=<default>);
bool EndArcArrow(picture, path, pen, marginT(path, pen))(arrowhead arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>);
bool EndArcArrow(picture, path, pen, marginT(path, pen));
void tensorshade(frame f, path[] g, bool stroke=<default>, pen fillrule=<default>, pen[][] p, path[] b=<default>, pair[][] z=<default>, bool copy=<default>);
void tensorshade(picture pic=<default>, path[] g, bool stroke=<default>, pen fillrule=<default>, pen[][] p, path[] b=<default>, pair[][] z=<default>, bool copy=<default>);
void tensorshade(frame f, path[] g, bool stroke=<default>, pen fillrule=<default>, pen[] p, path b=<default>, pair[] z=<default>);
void tensorshade(picture pic=<default>, path[] g, bool stroke=<default>, pen fillrule=<default>, pen[] p, path b=<default>, pair[] z=<default>);
file _outpipe;
void gouraudshade(frame f, path[] g, bool stroke=<default>, pen fillrule=<default>, pen[] p, pair[] z, int[] edges, bool copy=<default>);
void gouraudshade(frame f, path[] g, bool stroke=<default>, pen fillrule=<default>, pen[] p, int[] edges, bool copy=<default>);
void gouraudshade(picture pic=<default>, path[] g, bool stroke=<default>, pen fillrule=<default>, pen[] p, pair[] z, int[] edges, bool copy=<default>);
void gouraudshade(picture pic=<default>, path[] g, bool stroke=<default>, pen fillrule=<default>, pen[] p, int[] edges, bool copy=<default>);
pair getpair(string name=<default>, pair default=<default>, string prompt=<default>, bool store=<default>);
void axialshade(frame f, path[] g, bool stroke=<default>, pen pena, pair a, bool extenda=<default>, pen penb, pair b, bool extendb=<default>, bool copy=<default>);
void axialshade(picture pic=<default>, path[] g, bool stroke=<default>, pen pena, pair a, bool extenda=<default>, pen penb, pair b, bool extendb=<default>, bool copy=<default>);
pen chartreuse;
void latticeshade(frame f, path[] g, bool stroke=<default>, pen fillrule=<default>, pen[][] p, transform t=<default>, bool copy=<default>);
void latticeshade(picture pic=<default>, path[] g, bool stroke=<default>, pen fillrule=<default>, pen[][] p, bool copy=<default>);
void fill(frame f, path[] g, pen p=<default>, bool copy=<default>);
void fill(pair origin, picture pic=<default>, path[] g, pen p=<default>);
void fill(picture pic=<default>, path[] g, pen p=<default>, bool copy=<default>);
path fill(frame dest, frame src, filltype filltype=<default>, real xmargin=<default>, real ymargin=<default>);
void _draw(frame f, path g, pen p);
void _draw(frame f, path3 g, triple center=<default>, pen[] p, real opacity, real shininess, real metallic, real fresnel0, int interaction=<default>);
void _draw(picture pic, path g, pen p, marginT margin(path, pen));
void initdefaults();
void erase(frame f);
string erase(string s, int pos, int n);
void erase(picture pic=<default>);
string jobname(string name);
void print_random_addresses(int n=<default>);
void generate_random_backtrace();
marginT TrueMargin(path, pen)(real begin, real end=<default>);
real bezier(real a, real b, real c, real d, real t);
pair bezier(pair a, pair b, pair c, pair d, real t);
triple bezier(triple a, triple b, triple c, triple d, real t);
restricted pen squarecap;
bool isometry(transform t);
guide operator ::(... guide[]);
pen Helvetica(string series=<default>, string shape=<default>);
transform reflect(pair a, pair b);
transform rotate(real angle, pair z=<default>);
restricted bool IgnoreAspect;
void postscript(frame f, string s);
void postscript(frame f, string s, pair min, pair max);
void postscript(picture pic=<default>, string s);
void postscript(picture pic=<default>, string s, pair min, pair max);
transform slant(real s);
transform yscale(real y);
transform inverse(transform t);
real[][] inverse(real[][] a);
pen darkgrey;
transform xscale(real x);
transform shiftless(transform t);
real[][] shiftless(real[][] t);
real[] _cputime();
guide reverse(guide g);
string reverse(string s);
path reverse(path p);
path3 reverse(path3 p);
triple[] reverse(triple[] a);
int[] reverse(int[] a);
real[] reverse(real[] a);
int[] reverse(int n);
string[] reverse(string[] a);
pair[] reverse(pair[] a);
bool[] reverse(bool[] a);
real[] curlSpecifier(guide g, int t);
bool Blank(picture, path, pen, marginT(path, pen));
tensionSpecifier tensionSpecifier(guide g, int t);
restricted bool3 default;
pair[] controlSpecifier(guide g, int t);
pen red;
pair[] dirSpecifier(guide g, int t);
pen longdashed;
pair point(guide g, int t);
pair point(path p, int t);
pair point(path p, real t);
triple point(path3 p, int t);
triple point(path3 p, real t);
pair point(frame f, pair dir);
pair point(picture pic=<default>, pair dir, bool user=<default>);
pair point(object F, pair dir, transform t=<default>);
int length(guide g);
int length(string s);
real length(pair z);
real length(triple v);
int length(path p);
int length(path3 p);
int size(guide g);
pair size(frame f);
int size(path p);
int size(path[] p);
int size(path3 p);
void size(picture dest, picture src);
pair size(picture pic, bool user=<default>);
void size(picture pic=<default>, transform t);
void size(picture pic=<default>, real x, real y=<default>, bool keepAspect=<default>);
void size(picture pic=<default>, real xsize, real ysize, pair min, pair max);
string texify(string s);
guide operator controls(pair zout, pair zin);
guide operator controls(pair z);
bool empty(frame f);
tensionSpecifier operator tension(real tout, real tin, bool atleast);
tensionSpecifier operator tension(real t, bool atLeast);
void end(picture pic=<default>);
curlSpecifier operator curl(real gamma, int p);
guide operator spec(pair z, int p);
void list(string s, bool imports=<default>);
string cd(string s=<default>);
restricted int Move;
string location();
string xasyKEY();
void xasyKEY(string s);
bool pdf();
void _eval(string s, bool embedded, bool interactivewrite=<default>);
void _eval(code s, bool embedded);
void usleep(int microseconds);
void sleep(int seconds);
real Sin(real deg);
void assert(bool b, string s=<default>);
restricted pair Align;
void exit();
void abort(string s=<default>);
string locale(string s=<default>);
string defaultseparator;
string asydir();
bool view();
int system(string[] s);
int system(string s);
bool interactive();
pen colorless(pen p);
bool straight(path p, int t);
bool straight(path3 p, int t);
pen makepen(path p);
realschur schur(real[][] a);
schur schur(pair[][] a);
path nib(pen p);
transform transform(pen p);
pair relpoint(path p, real l);
pair[][] transpose(pair[][] a);
pen[][] transpose(pen[][] a);
string[][] transpose(string[][] a);
real[][] transpose(real[][] a);
pen overwrite(int n);
int overwrite(pen p=<default>);
real lineskip(pen p=<default>);
pen fontsize(real size, real lineskip);
real fontsize(pen p=<default>);
pen fontsize(real size);
string font(pen p=<default>);
pen font(string name, string options=<default>);
pen font(string encoding, string family, string series, string shape);
pen font(string name, real size, string options=<default>);
void newpage(frame f);
void newpage(picture pic=<default>);
pen fontcommand(string s);
pen linewidth(real x);
real linewidth(pen p=<default>);
real arrowlength;
pen miterlimit(real x);
real miterlimit(pen p=<default>);
pen linecap(int n);
int linecap(pen p=<default>);
bool adjust(pen p);
pen adjust(pen p, real arclength, bool cyclic);
bool scale(pen p);
transform scale(real x);
transform scale(real x, real y);
real[][] scale(real x, real y, real z);
transform Shift(transform t);
real fmod(real x, real y);
real offset(pen p);
real orient(pair a, pair b, pair c);
real orient(triple a, triple b, triple c, triple d);
pen linetype(real[] pattern, real offset=<default>, bool scale=<default>, bool adjust=<default>);
real[] linetype(pen p=<default>);
pen linetype(string pattern, real offset=<default>, bool scale=<default>, bool adjust=<default>);
string blend(pen p);
void endclip(frame f);
void endclip(picture pic=<default>);
pen opacity(real opacity=<default>, string blend=<default>);
real opacity(pen p);
pen fillrule(int n);
int fillrule(pen p);
restricted real[][] identity4;
marker[] MarkFill;
pen pattern(string s);
string pattern(pen p);
pen solid;
string colorspace(pen p);
real byteinv(int x);
int byte(real x);
restricted bool Aspect;
string hex(pen p);
int hex(string s);
real[] colors(pen p);
void DOSnewl(file file);
pen cmyk(pen p);
pen cmyk(real c, real m, real y, real k);
pen rgb(pen p);
pen rgb(real r, real g, real b);
pen rgb(real[] a);
pen rgb(string s);
pen gray(pen p);
pen gray(real gray);
pen gray;
bool invisible(pen p);
pen invisible();
pen invisible;
void defaultpen(pen p);
pen defaultpen();
restricted pen defaultpen;
void defaultpen(real w);
void resetdefaultpen();
bool isnan(real x);
bool cyclic(guide g);
bool cyclic(path p);
bool cyclic(path3 p);
void printBytecode(<open>);
pen currentpen;
restricted string VERSION;
bool alias(pair[][] a, pair[][] b);
bool alias(guide[] a, guide[] b);
bool alias(pair[] a, pair[] b);
bool alias(int[] a, int[] b);
bool alias(string[][] a, string[][] b);
bool alias(bool3 a, bool3 b);
bool alias(bounds a, bounds b);
bool alias(light a, light b);
bool alias(autoscaleT a, autoscaleT b);
bool alias(ScaleT a, ScaleT b);
bool alias(align a, align b);
bool alias(cputime a, cputime b);
bool alias(real[][] a, real[][] b);
bool alias(slice a, slice b);
bool alias(filltype a, filltype b);
bool alias(Legend a, Legend b);
bool alias(picture a, picture b);
bool alias(side a, side b);
bool alias(position a, position b);
bool alias(realschur a, realschur b);
bool alias(string[] a, string[] b);
bool alias(frame[] a, frame[] b);
bool alias(bool[] a, bool[] b);
bool alias(scaling a, scaling b);
bool alias(pairOrTriple a, pairOrTriple b);
bool alias(schur a, schur b);
bool alias(void()()[] a, void()()[] b);
bool alias(pen[][] a, pen[][] b);
bool alias(path[] a, path[] b);
bool alias(hsv a, hsv b);
bool alias(coord a, coord b);
bool alias(scaleT a, scaleT b);
bool alias(arrowhead a, arrowhead b);
bool alias(triple[] a, triple[] b);
bool alias(coords2 a, coords2 b);
bool alias(node a, node b);
bool alias(object a, object b);
bool alias(processtime a, processtime b);
bool alias(real[] a, real[] b);
bool alias(bool3[] a, bool3[] b);
bool alias(Legend[] a, Legend[] b);
bool alias(picture[] a, picture[] b);
bool alias(pen[] a, pen[] b);
bool alias(coord[] a, coord[] b);
bool alias(object[] a, object[] b);
bool alias(marginT a, marginT b);
bool alias(transformation a, transformation b);
bool alias(projection a, projection b);
bool alias(coords3 a, coords3 b);
bool alias(Label a, Label b);
bool alias(marker a, marker b);
bool alias(marker[] a, marker[] b);
bool alias(Label[] a, Label[] b);
restricted real pi;
restricted int randMax;
pen heavycyan;
marginT PenMargin(path, pen)(real begin, real end=<default>);
marginT PenMargin(path, pen);
restricted int realDigits;
restricted real realEpsilon;
restricted pair NE;
restricted real realMin;
restricted real realMax;
restricted real nan;
restricted real infinity;
void xmap(string key, transform t=<default>);
restricted real inf;
restricted int intMin;
restricted int intMax;
pen palered;
real[] map(real f(pair), pair[] a);
int[] map(int f(real), real[] a);
Legend[] map(Legend f(Legend), Legend[] a);
picture[] map(picture f(picture), picture[] a);
frame[] map(frame f(frame), frame[] a);
pen[][] map(pen[] f(pen[]), pen[][] a);
triple[] map(triple f(triple), triple[] a);
pen[] map(pen f(pen), pen[] a);
bool3[] map(bool3 f(bool3), bool3[] a);
pair[] map(pair f(pair), pair[] a);
string[] map(string f(string), string[] a);
marker[] map(marker f(marker), marker[] a);
Label[] map(Label f(Label), Label[] a);
void()()[] map(void f()()(void()()), void()()[] a);
pair[][] map(pair[] f(pair[]), pair[][] a);
real[] map(real f(real), real[] a);
object[] map(object f(object), object[] a);
int[] map(int f(int), int[] a);
string[][] map(string[] f(string[]), string[][] a);
coord[] map(coord f(coord), coord[] a);
bool[] map(bool f(bool), bool[] a);
path[] map(path f(path), path[] a);
real[][] map(real[] f(real[]), real[][] a);
guide[] map(guide f(guide), guide[] a);
real identity(real x);
real[] identity(real[] a);
transform identity();
real[][] identity(int n);
restricted transform identity;
real pow10(real x);
real[] pow10(real[] a);
pen linejoin(int n);
int linejoin(pen p=<default>);
real ldexp(real x, int e);
real log1p(real x);
real[] log1p(real[] a);
path brace(pair a, pair b, real amplitude=<default>);
void deactivatequote(picture pic=<default>);
string format(string format, int x, string locale=<default>);
string format(string format, bool forcemath=<default>, string separator, real x, string locale=<default>);
string format(string format=<default>, bool forcemath=<default>, real x, string locale=<default>);
real[][][] _schur(real[][] a);
pair[][][] _schur(pair[][] a);
real expm1(real x);
real[] expm1(real[] a);
void label(frame f, string s, string size, transform t, pair position, pair align, pen p);
void label(picture pic=<default>, Label L, align align=<default>, pen p=<default>, filltype filltype=<default>);
void label(pair origin, picture pic=<default>, Label L, align align=<default>, pen p=<default>, filltype filltype=<default>);
void label(frame f, Label L, pair position, align align=<default>, pen p=<default>, filltype filltype=<default>);
void label(picture pic=<default>, Label L, pair position, align align=<default>, pen p=<default>, filltype filltype=<default>);
void label(frame f, Label L, align align=<default>, pen p=<default>, filltype filltype=<default>);
void label(picture pic=<default>, Label L, explicit guide g, align align=<default>, pen p=<default>, filltype filltype=<default>);
void label(picture pic=<default>, Label L, explicit path g, align align=<default>, pen p=<default>, filltype filltype=<default>);
real fabs(real x);
real[] fabs(real[] a);
string stripsuffix(string f, string suffix=<default>);
real cbrt(real x);
real[] cbrt(real[] a);
real sqrt(real x);
real[] sqrt(real[] a);
pair sqrt(explicit pair z);
bool all(bool[] a);
real atanh(real x);
real[] atanh(real[] a);
real acosh(real x);
real[] acosh(real[] a);
transform shift(transform t);
transform shift(pair z);
transform shift(real x, real y);
transform shift(frame f, pair align);
real asinh(real x);
real[] asinh(real[] a);
pen ZapfDingbats(string series=<default>, string shape=<default>);
real tanh(real x);
real[] tanh(real[] a);
real cosh(real x);
real[] cosh(real[] a);
real sinh(real x);
real[] sinh(real[] a);
real straightness(triple z0, triple c0, triple c1, triple z1);
real straightness(path3 p, int t);
real log10(real x);
real[] log10(real[] a);
pair midpoint(path p);
real exp(real x);
real[] exp(real[] a);
pair exp(explicit pair z);
pen purple;
string italic(string s);
real atan(real x);
real[] atan(real[] a);
real acos(real x);
real[] acos(real[] a);
path roundbox(frame dest, frame src=<default>, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
path roundbox(frame f, Label L, real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
real asin(real x);
real[] asin(real[] a);
real tan(real x);
real[] tan(real[] a);
pen Magenta;
real cos(real x);
real[] cos(real[] a);
pair cos(explicit pair z);
filltype RadialShadeDraw(real xmargin=<default>, real ymargin=<default>, pen penc, pen penr, pen drawpen=<default>);
real sin(real x);
real[] sin(real[] a);
pair sin(explicit pair z);
path polygon(int n);
guide operator --(... guide[]);
void none(file file);
int factorial(int n);
real log(real x);
real[] log(real[] a);
pair log(explicit pair z);
guide operator ..(... guide[]);
guide operator ..(... guide[])(tensionSpecifier t);
pair operator tuple(real x, real y);
triple operator tuple(real x, real y, real z);
transform operator tuple(real x, real y, real xx, real xy, real yx, real yy);
int[][] diagonal(... int[]);
real[][] diagonal(... real[]);
pair[][] diagonal(... pair[]);
path[] texpath(string s, pen p, bool tex=<default>, bool bbox=<default>);
path[] texpath(Label L, bool tex=<default>, bool bbox=<default>);
bool uptodate();
int operator #(int a, int b);
int[] operator #(int a, int[] b);
int[] operator #(int[] a, int b);
int[] operator #(int[] a, int[] b);
int operator %(int a, int b);
int[] operator %(int a, int[] b);
int[] operator %(int[] a, int b);
int[] operator %(int[] a, int[] b);
real operator %(real a, real b);
real[] operator %(real a, real[] b);
real[] operator %(real[] a, real b);
real[] operator %(real[] a, real[] b);
int search(int[] a, int key);
int search(real[] a, real key);
int search(string[] a, string key);
int search(void()()[] a, void key()(), bool less(void()(), void()()));
int search(marker[] a, marker key, bool less(marker, marker));
int search(Label[] a, Label key, bool less(Label, Label));
int search(real[] a, real key, bool less(real, real));
int search(guide[] a, guide key, bool less(guide, guide));
int search(pair[] a, pair key, bool less(pair, pair));
int search(frame[] a, frame key, bool less(frame, frame));
int search(object[] a, object key, bool less(object, object));
int search(Legend[] a, Legend key, bool less(Legend, Legend));
int search(picture[] a, picture key, bool less(picture, picture));
int search(int[] a, int key, bool less(int, int));
int search(string[] a, string key, bool less(string, string));
int search(path[] a, path key, bool less(path, path));
int search(coord[] a, coord key, bool less(coord, coord));
int search(pen[] a, pen key, bool less(pen, pen));
int search(bool3[] a, bool3 key, bool less(bool3, bool3));
int search(bool[] a, bool key, bool less(bool, bool));
int search(triple[] a, triple key, bool less(triple, triple));
int[] sort(int[] a);
int[][] sort(int[][] a);
real[] sort(real[] a);
real[][] sort(real[][] a);
string[] sort(string[] a);
string[][] sort(string[][] a);
path[] sort(path[] a, bool less(path, path), bool stable=<default>);
pen[][] sort(pen[][] a, bool less(pen[], pen[]), bool stable=<default>);
pair[][] sort(pair[][] a, bool less(pair[], pair[]), bool stable=<default>);
Legend[] sort(Legend[] a, bool less(Legend, Legend), bool stable=<default>);
picture[] sort(picture[] a, bool less(picture, picture), bool stable=<default>);
pen[] sort(pen[] a, bool less(pen, pen), bool stable=<default>);
bool[] sort(bool[] a, bool less(bool, bool), bool stable=<default>);
void()()[] sort(void()()[] a, bool less(void()(), void()()), bool stable=<default>);
frame[] sort(frame[] a, bool less(frame, frame), bool stable=<default>);
marker[] sort(marker[] a, bool less(marker, marker), bool stable=<default>);
Label[] sort(Label[] a, bool less(Label, Label), bool stable=<default>);
int[] sort(int[] a, bool less(int, int), bool stable=<default>);
string[][] sort(string[][] a, bool less(string[], string[]), bool stable=<default>);
bool3[] sort(bool3[] a, bool less(bool3, bool3), bool stable=<default>);
real[] sort(real[] a, bool less(real, real), bool stable=<default>);
string[] sort(string[] a, bool less(string, string), bool stable=<default>);
object[] sort(object[] a, bool less(object, object), bool stable=<default>);
pair[] sort(pair[] a, bool less(pair, pair), bool stable=<default>);
real[][] sort(real[][] a, bool less(real[], real[]), bool stable=<default>);
triple[] sort(triple[] a, bool less(triple, triple), bool stable=<default>);
coord[] sort(coord[] a, bool less(coord, coord), bool stable=<default>);
guide[] sort(guide[] a, bool less(guide, guide), bool stable=<default>);
pair postcontrol(path p, int t);
pair postcontrol(path p, real t);
triple postcontrol(path3 p, int t);
triple postcontrol(path3 p, real t);
int max(int a, int b);
int[] max(int a, int[] b);
int[] max(int[] a, int b);
int[] max(int[] a, int[] b);
int max(int[] a);
int max(int[][] a);
int max(int[][][] a);
real max(real a, real b);
real[] max(real a, real[] b);
real[] max(real[] a, real b);
real[] max(real[] a, real[] b);
real max(real[] a);
real max(real[][] a);
real max(real[][][] a);
string max(string a, string b);
string[] max(string a, string[] b);
string[] max(string[] a, string b);
string[] max(string[] a, string[] b);
string max(string[] a);
string max(string[][] a);
string max(string[][][] a);
pair max(pen p);
pair max(frame f);
pair max(explicit path p);
pair max(path[] p);
triple max(path3 p);
real max(real M, scaling s, coord[] c);
pair max(picture pic, bool user=<default>);
int max(... int[] a);
real max(... real[] a);
void restore();
pen basealign(int n);
int basealign(pen p=<default>);
restricted pen basealign;
int min(int a, int b);
int[] min(int a, int[] b);
int[] min(int[] a, int b);
int[] min(int[] a, int[] b);
int min(int[] a);
int min(int[][] a);
int min(int[][][] a);
real min(real a, real b);
real[] min(real a, real[] b);
real[] min(real[] a, real b);
real[] min(real[] a, real[] b);
real min(real[] a);
real min(real[][] a);
real min(real[][][] a);
string min(string a, string b);
string[] min(string a, string[] b);
string[] min(string[] a, string b);
string[] min(string[] a, string[] b);
string min(string[] a);
string min(string[][] a);
string min(string[][][] a);
pair min(pen p);
pair min(frame f);
pair min(explicit path p);
pair min(path[] p);
triple min(path3 p);
real min(... real[] a);
real min(real m, scaling s, coord[] c);
pair min(picture pic, bool user=<default>);
int min(... int[] a);
void srand(int seed);
bool operator >(int a, int b);
bool[] operator >(int a, int[] b);
bool[] operator >(int[] a, int b);
bool[] operator >(int[] a, int[] b);
bool operator >(real a, real b);
bool[] operator >(real a, real[] b);
bool[] operator >(real[] a, real b);
bool[] operator >(real[] a, real[] b);
bool operator >(string a, string b);
bool[] operator >(string a, string[] b);
bool[] operator >(string[] a, string b);
bool[] operator >(string[] a, string[] b);
bool operator >=(int a, int b);
bool[] operator >=(int a, int[] b);
bool[] operator >=(int[] a, int b);
bool[] operator >=(int[] a, int[] b);
bool operator >=(real a, real b);
bool[] operator >=(real a, real[] b);
bool[] operator >=(real[] a, real b);
bool[] operator >=(real[] a, real[] b);
bool operator >=(string a, string b);
bool[] operator >=(string a, string[] b);
bool[] operator >=(string[] a, string b);
bool[] operator >=(string[] a, string[] b);
bool operator >=(coord a, coord b);
bool operator <=(int a, int b);
bool[] operator <=(int a, int[] b);
bool[] operator <=(int[] a, int b);
bool[] operator <=(int[] a, int[] b);
bool operator <=(real a, real b);
bool[] operator <=(real a, real[] b);
bool[] operator <=(real[] a, real b);
bool[] operator <=(real[] a, real[] b);
bool operator <=(string a, string b);
bool[] operator <=(string a, string[] b);
bool[] operator <=(string[] a, string b);
bool[] operator <=(string[] a, string[] b);
bool operator <=(coord a, coord b);
bool operator <(int a, int b);
bool[] operator <(int a, int[] b);
bool[] operator <(int[] a, int b);
bool[] operator <(int[] a, int[] b);
bool operator <(real a, real b);
bool[] operator <(real a, real[] b);
bool[] operator <(real[] a, real b);
bool[] operator <(real[] a, real[] b);
bool operator <(string a, string b);
bool[] operator <(string a, string[] b);
bool[] operator <(string[] a, string b);
bool[] operator <(string[] a, string[] b);
pair[] conj(pair[] a);
pair[][] conj(pair[][] a);
pair conj(pair z);
restricted side LeftSide;
path nullpath;
Legend[] copy(Legend[] a, int depth=<default>);
picture[] copy(picture[] a, int depth=<default>);
guide[] copy(guide[] a, int depth=<default>);
real[] copy(real[] a, int depth=<default>);
triple[] copy(triple[] a, int depth=<default>);
bool[] copy(bool[] a, int depth=<default>);
real[][] copy(real[][] a, int depth=<default>);
pen[] copy(pen[] a, int depth=<default>);
pen[][] copy(pen[][] a, int depth=<default>);
path[] copy(path[] a, int depth=<default>);
string[] copy(string[] a, int depth=<default>);
coord[] copy(coord[] a, int depth=<default>);
void()()[] copy(void()()[] a, int depth=<default>);
int[] copy(int[] a, int depth=<default>);
string[][] copy(string[][] a, int depth=<default>);
object[] copy(object[] a, int depth=<default>);
frame[] copy(frame[] a, int depth=<default>);
bool3[] copy(bool3[] a, int depth=<default>);
pair[] copy(pair[] a, int depth=<default>);
marker[] copy(marker[] a, int depth=<default>);
Label[] copy(Label[] a, int depth=<default>);
pair[][] copy(pair[][] a, int depth=<default>);
real[] abs(pair[] a);
real[] abs(triple[] a);
real abs(real x);
real[] abs(real[] a);
real abs(pair z);
real abs(triple v);
int abs(int x);
void radialshade(frame f, path[] g, bool stroke=<default>, pen pena, pair a, real ra, bool extenda=<default>, pen penb, pair b, real rb, bool extendb=<default>, bool copy=<default>);
void radialshade(picture pic=<default>, path[] g, bool stroke=<default>, pen pena, pair a, real ra, bool extenda=<default>, pen penb, pair b, real rb, bool extendb=<default>, bool copy=<default>);
pair maxbound(pair a, pair b);
triple maxbound(triple a, triple b);
pair maxbound(pair[] a);
pair maxbound(pair[][] a);
pair maxbound(pair[][][] a);
triple maxbound(triple[] a);
triple maxbound(triple[][] a);
triple maxbound(triple[][][] a);
pair minbound(pair a, pair b);
triple minbound(triple a, triple b);
pair minbound(pair[] a);
pair minbound(pair[][] a);
pair minbound(pair[][][] a);
triple minbound(triple[] a);
triple minbound(triple[][] a);
triple minbound(triple[][][] a);
real operator /(real a, real b);
real[] operator /(real a, real[] b);
real[] operator /(real[] a, real b);
real[] operator /(real[] a, real[] b);
real[][] operator /(real[][] a, real b);
pair operator /(pair a, pair b);
pair[] operator /(pair a, pair[] b);
pair[] operator /(pair[] a, pair b);
pair[] operator /(pair[] a, pair[] b);
pair[][] operator /(pair[][] a, pair b);
triple[] operator /(triple[] a, real b);
real operator /(int a, int b);
real[] operator /(int[] a, int b);
real[] operator /(int a, int[] b);
real[] operator /(int[] a, int[] b);
triple operator /(triple v, real x);
real interp(real a, real b, real t);
pair interp(explicit pair a, explicit pair b, real t);
triple interp(triple a, triple b, real t);
pen interp(pen a, pen b, real t);
bool primitive();
int operator *(int a, int b);
int[] operator *(int a, int[] b);
int[] operator *(int[] a, int b);
int[] operator *(int[] a, int[] b);
int[][] operator *(int a, int[][] b);
int[][] operator *(int[][] a, int b);
real operator *(real a, real b);
real[] operator *(real a, real[] b);
real[] operator *(real[] a, real b);
real[] operator *(real[] a, real[] b);
real[][] operator *(real a, real[][] b);
real[][] operator *(real[][] a, real b);
pair operator *(pair a, pair b);
pair[] operator *(pair a, pair[] b);
pair[] operator *(pair[] a, pair b);
pair[] operator *(pair[] a, pair[] b);
pair[][] operator *(pair a, pair[][] b);
pair[][] operator *(pair[][] a, pair b);
triple[] operator *(real a, triple[] b);
triple[][] operator *(real a, triple[][] b);
triple[] operator *(triple[] a, real b);
triple[][] operator *(triple[][] a, real b);
pen operator *(real a, pen b);
pen operator *(pen a, real b);
transform operator *(transform a, transform b);
pair operator *(transform t, pair z);
path operator *(transform t, path g);
pen operator *(transform t, pen p);
frame operator *(transform t, frame f);
frame operator *(real[][] t, frame f);
real[] operator *(real[][] a, real[] b);
real[] operator *(real[] a, real[][] b);
int[][] operator *(int[][] a, int[][] b);
real[][] operator *(real[][] a, real[][] b);
pair[][] operator *(pair[][] a, pair[][] b);
triple operator *(real[][] t, triple v);
triple operator *(real x, triple v);
triple operator *(triple v, real x);
path3 operator *(real[][] t, path3 g);
bounds operator *(transform t, bounds b);
side operator *(real x, side s);
Label operator *(transform t, Label L);
object operator *(transform t, explicit object F);
picture operator *(real[][] t, picture orig);
path[] operator *(transform t, explicit path[] p);
pair[] operator *(transform t, pair[] z);
Label operator *(real[][] t, Label L);
picture operator *(transform t, picture orig);
real latitude(triple v, bool warn=<default>);
int sum(int[] a);
real sum(real[] a);
pair sum(pair[] a);
triple sum(triple[] a);
int sum(bool[] a);
bool initialized(int a);
bool initialized(real a);
bool initialized(pair a);
bool initialized(triple a);
int operator -(int a, int b);
int[] operator -(int a, int[] b);
int[] operator -(int[] a, int b);
int[] operator -(int[] a, int[] b);
int[][] operator -(int[][] a, int[][] b);
int operator -(int a);
int[] operator -(int[] a);
int[][] operator -(int[][] a);
real operator -(real a, real b);
real[] operator -(real a, real[] b);
real[] operator -(real[] a, real b);
real[] operator -(real[] a, real[] b);
real[][] operator -(real[][] a, real[][] b);
real operator -(real a);
real[] operator -(real[] a);
real[][] operator -(real[][] a);
pair operator -(pair a, pair b);
pair[] operator -(pair a, pair[] b);
pair[] operator -(pair[] a, pair b);
pair[] operator -(pair[] a, pair[] b);
pair[][] operator -(pair[][] a, pair[][] b);
pair operator -(pair a);
pair[] operator -(pair[] a);
pair[][] operator -(pair[][] a);
triple operator -(triple a, triple b);
triple[] operator -(triple a, triple[] b);
triple[] operator -(triple[] a, triple b);
triple[] operator -(triple[] a, triple[] b);
triple[][] operator -(triple[][] a, triple[][] b);
triple operator -(triple a);
triple[] operator -(triple[] a);
triple[][] operator -(triple[][] a);
void gsave(frame f);
void write(file file=<default>, string s=<default>, bool x, void suffix(file)=<default>, ... bool[]);
void write(file file=<default>, string s=<default>, explicit bool[] a, ... bool[][]);
void write(file file=<default>, bool[][]);
void write(file file=<default>, bool[][][]);
void write(file file=<default>, string s=<default>, int x, void suffix(file)=<default>, ... int[]);
void write(file file=<default>, string s=<default>, explicit int[] a, ... int[][]);
void write(file file=<default>, int[][]);
void write(file file=<default>, int[][][]);
void write(file file=<default>, string s=<default>, real x, void suffix(file)=<default>, ... real[]);
void write(file file=<default>, string s=<default>, explicit real[] a, ... real[][]);
void write(file file=<default>, real[][]);
void write(file file=<default>, real[][][]);
void write(file file=<default>, string s=<default>, pair x, void suffix(file)=<default>, ... pair[]);
void write(file file=<default>, string s=<default>, explicit pair[] a, ... pair[][]);
void write(file file=<default>, pair[][]);
void write(file file=<default>, pair[][][]);
void write(file file=<default>, string s=<default>, triple x, void suffix(file)=<default>, ... triple[]);
void write(file file=<default>, string s=<default>, explicit triple[] a, ... triple[][]);
void write(file file=<default>, triple[][]);
void write(file file=<default>, triple[][][]);
void write(file file=<default>, string s=<default>, string x, void suffix(file)=<default>, ... string[]);
void write(file file=<default>, string s=<default>, explicit string[] a, ... string[][]);
void write(file file=<default>, string[][]);
void write(file file=<default>, string[][][]);
void write(file file=<default>, string s, void suffix(file)=<default>);
void write(file file=<default>, string s=<default>, transform x, void suffix(file)=<default>, ... transform[]);
void write(file file=<default>, string s=<default>, guide x, void suffix(file)=<default>, ... guide[]);
void write(file file=<default>, string s=<default>, pen x, void suffix(file)=<default>, ... pen[]);
void write(file file, string s=<default>, explicit guide[] x, void suffix(file)=<default>);
void write(string s=<default>, cputime c, string format=<default>, void suffix(file)=<default>);
void write(string s=<default>, explicit path[] x, void suffix(file)=<default>);
void write(file file, void suffix(file)=<default>);
void write(file file=<default>, string s=<default>, pen[] p);
void write(void suffix(file)=<default>);
void write(string s=<default>, bool3 b, void suffix(file)=<default>);
void write(file file, string s=<default>, explicit path[] x, void suffix(file)=<default>);
void write(file file, string s=<default>, bool3 b, void suffix(file)=<default>);
void write(file file=<default>, align align, void suffix(file)=<default>);
void write(file file, string s=<default>, cputime c, string format=<default>, void suffix(file)=<default>);
void write(pairOrTriple a);
void write(string s=<default>, explicit guide[] x, void suffix(file)=<default>);
void write(file file=<default>, Label L, void suffix(file)=<default>);
bool operator !=(bool a, bool b);
bool[] operator !=(bool a, bool[] b);
bool[] operator !=(bool[] a, bool b);
bool[] operator !=(bool[] a, bool[] b);
bool operator !=(bool[][] a, bool[][] b);
bool operator !=(int a, int b);
bool[] operator !=(int a, int[] b);
bool[] operator !=(int[] a, int b);
bool[] operator !=(int[] a, int[] b);
bool operator !=(int[][] a, int[][] b);
bool operator !=(real a, real b);
bool[] operator !=(real a, real[] b);
bool[] operator !=(real[] a, real b);
bool[] operator !=(real[] a, real[] b);
bool operator !=(real[][] a, real[][] b);
bool operator !=(pair a, pair b);
bool[] operator !=(pair a, pair[] b);
bool[] operator !=(pair[] a, pair b);
bool[] operator !=(pair[] a, pair[] b);
bool operator !=(pair[][] a, pair[][] b);
bool operator !=(triple a, triple b);
bool[] operator !=(triple a, triple[] b);
bool[] operator !=(triple[] a, triple b);
bool[] operator !=(triple[] a, triple[] b);
bool operator !=(triple[][] a, triple[][] b);
bool operator !=(string a, string b);
bool[] operator !=(string a, string[] b);
bool[] operator !=(string[] a, string b);
bool[] operator !=(string[] a, string[] b);
bool operator !=(string[][] a, string[][] b);
bool[] operator !=(pen[] a, pen[] b);
bool operator !=(pen a, pen b);
bool operator !=(transform a, transform b);
bool operator !=(file a, file b);
bool operator !=(path a, path b);
bool operator !=(path3 a, path3 b);
bool operator !=(bool3 a, bool3 b);
bool operator !=(bounds a, bounds b);
bool operator !=(light a, light b);
bool operator !=(autoscaleT a, autoscaleT b);
bool operator !=(ScaleT a, ScaleT b);
bool operator !=(align a, align b);
bool operator !=(cputime a, cputime b);
bool operator !=(slice a, slice b);
bool operator !=(filltype a, filltype b);
bool operator !=(Legend a, Legend b);
bool operator !=(picture a, picture b);
bool operator !=(side a, side b);
bool operator !=(position a, position b);
bool operator !=(realschur a, realschur b);
bool operator !=(bool3 a, bool b);
bool operator !=(scaling a, scaling b);
bool operator !=(pairOrTriple a, pairOrTriple b);
bool operator !=(schur a, schur b);
bool operator !=(bool a, bool3 b);
bool operator !=(hsv a, hsv b);
bool operator !=(coord a, coord b);
bool operator !=(scaleT a, scaleT b);
bool operator !=(arrowhead a, arrowhead b);
bool operator !=(coords2 a, coords2 b);
bool operator !=(node a, node b);
bool operator !=(object a, object b);
bool operator !=(processtime a, processtime b);
bool operator !=(marginT a, marginT b);
bool operator !=(transformation a, transformation b);
bool operator !=(projection a, projection b);
bool operator !=(coords3 a, coords3 b);
bool operator !=(Label a, Label b);
bool operator !=(marker a, marker b);
bool operator ==(bool a, bool b);
bool[] operator ==(bool a, bool[] b);
bool[] operator ==(bool[] a, bool b);
bool[] operator ==(bool[] a, bool[] b);
bool operator ==(bool[][] a, bool[][] b);
bool operator ==(int a, int b);
bool[] operator ==(int a, int[] b);
bool[] operator ==(int[] a, int b);
bool[] operator ==(int[] a, int[] b);
bool operator ==(int[][] a, int[][] b);
bool operator ==(real a, real b);
bool[] operator ==(real a, real[] b);
bool[] operator ==(real[] a, real b);
bool[] operator ==(real[] a, real[] b);
bool operator ==(real[][] a, real[][] b);
bool operator ==(pair a, pair b);
bool[] operator ==(pair a, pair[] b);
bool[] operator ==(pair[] a, pair b);
bool[] operator ==(pair[] a, pair[] b);
bool operator ==(pair[][] a, pair[][] b);
bool operator ==(triple a, triple b);
bool[] operator ==(triple a, triple[] b);
bool[] operator ==(triple[] a, triple b);
bool[] operator ==(triple[] a, triple[] b);
bool operator ==(triple[][] a, triple[][] b);
bool operator ==(string a, string b);
bool[] operator ==(string a, string[] b);
bool[] operator ==(string[] a, string b);
bool[] operator ==(string[] a, string[] b);
bool operator ==(string[][] a, string[][] b);
bool[] operator ==(pen[] a, pen[] b);
bool operator ==(pen a, pen b);
bool operator ==(transform a, transform b);
bool operator ==(file a, file b);
bool operator ==(path a, path b);
bool operator ==(path3 a, path3 b);
bool operator ==(slice a, slice b);
bool operator ==(filltype a, filltype b);
bool operator ==(Legend a, Legend b);
bool operator ==(picture a, picture b);
bool operator ==(side a, side b);
bool operator ==(position a, position b);
bool operator ==(realschur a, realschur b);
bool operator ==(bool3 a, bool b);
bool operator ==(scaling a, scaling b);
bool operator ==(pairOrTriple a, pairOrTriple b);
bool operator ==(schur a, schur b);
bool operator ==(bool a, bool3 b);
bool operator ==(hsv a, hsv b);
bool operator ==(coord a, coord b);
bool operator ==(scaleT a, scaleT b);
bool operator ==(arrowhead a, arrowhead b);
bool operator ==(coords2 a, coords2 b);
bool operator ==(node a, node b);
bool operator ==(object a, object b);
bool operator ==(processtime a, processtime b);
bool operator ==(marginT a, marginT b);
bool operator ==(transformation a, transformation b);
bool operator ==(projection a, projection b);
bool operator ==(coords3 a, coords3 b);
bool operator ==(Label a, Label b);
bool operator ==(marker a, marker b);
bool operator ==(bool3 a, bool3 b);
bool operator ==(bounds a, bounds b);
bool operator ==(light a, light b);
bool operator ==(autoscaleT a, autoscaleT b);
bool operator ==(ScaleT a, ScaleT b);
bool operator ==(align a, align b);
bool operator ==(cputime a, cputime b);
bool operator ^(bool a, bool b);
bool[] operator ^(bool a, bool[] b);
bool[] operator ^(bool[] a, bool b);
bool[] operator ^(bool[] a, bool[] b);
int operator ^(int a, int b);
int[] operator ^(int a, int[] b);
int[] operator ^(int[] a, int b);
int[] operator ^(int[] a, int[] b);
real operator ^(real a, real b);
real[] operator ^(real a, real[] b);
real[] operator ^(real[] a, real b);
real[] operator ^(real[] a, real[] b);
pair operator ^(pair a, pair b);
pair[] operator ^(pair a, pair[] b);
pair[] operator ^(pair[] a, pair b);
pair[] operator ^(pair[] a, pair[] b);
transform operator ^(transform t, int n);
real operator ^(real x, int y);
pair operator ^(pair z, int y);
bool operator |(bool a, bool b);
bool[] operator |(bool a, bool[] b);
bool[] operator |(bool[] a, bool b);
bool[] operator |(bool[] a, bool[] b);
pen NewCenturySchoolBook(string series=<default>, string shape=<default>);
void()()[] saveFunctions;
bool operator &(bool a, bool b);
bool[] operator &(bool a, bool[] b);
bool[] operator &(bool[] a, bool b);
bool[] operator &(bool[] a, bool[] b);
path operator &(path p, path q);
path3 operator &(path3 p, path3 q);
path operator &(path p, cycleToken tok);
string minipage(string s, real width=<default>);
real legendmaxrelativewidth;
real cross(explicit pair z, explicit pair w);
triple cross(triple u, triple v);
path cross(int n, bool round=<default>, real r=<default>);
string operator +(string a, string b);
int operator +(int a, int b);
int[] operator +(int a, int[] b);
int[] operator +(int[] a, int b);
int[] operator +(int[] a, int[] b);
int[][] operator +(int[][] a, int[][] b);
int operator +(int a);
int[] operator +(int[] a);
real operator +(real a, real b);
real[] operator +(real a, real[] b);
real[] operator +(real[] a, real b);
real[] operator +(real[] a, real[] b);
real[][] operator +(real[][] a, real[][] b);
real operator +(real a);
real[] operator +(real[] a);
pair operator +(pair a, pair b);
pair[] operator +(pair a, pair[] b);
pair[] operator +(pair[] a, pair b);
pair[] operator +(pair[] a, pair[] b);
pair[][] operator +(pair[][] a, pair[][] b);
pair operator +(pair a);
pair[] operator +(pair[] a);
triple operator +(triple a, triple b);
triple[] operator +(triple a, triple[] b);
triple[] operator +(triple[] a, triple b);
triple[] operator +(triple[] a, triple[] b);
triple[][] operator +(triple[][] a, triple[][] b);
triple operator +(triple a);
triple[] operator +(triple[] a);
pen operator +(pen a, pen b);
transform operator +(transform a, transform b);
pen operator +(pen p, real w);
pen[] operator +(pen a, pen[] b);
pen operator +(real w, pen p);
marginT operator +(path, pen)(marginT ma(path, pen), marginT mb(path, pen));
string operator +(... string[] a);
pen[] operator +(pen[] a, pen b);
real operator cast(int);
pair operator cast(int);
pair operator cast(real);
path operator cast(pair);
guide operator cast(pair);
guide operator cast(path);
path operator cast(guide);
file operator cast(null);
real[] operator cast(int[]);
pair[] operator cast(int[]);
pair[] operator cast(real[]);
real[][] operator cast(int[][]);
pair[][] operator cast(int[][]);
pair[][] operator cast(real[][]);
bool operator cast(file);
bool[] operator cast(file);
bool[][] operator cast(file);
bool[][][] operator cast(file);
int operator cast(file);
int[] operator cast(file);
int[][] operator cast(file);
int[][][] operator cast(file);
real operator cast(file);
real[] operator cast(file);
real[][] operator cast(file);
real[][][] operator cast(file);
pair operator cast(file);
pair[] operator cast(file);
pair[][] operator cast(file);
pair[][][] operator cast(file);
triple operator cast(file);
triple[] operator cast(file);
triple[][] operator cast(file);
triple[][][] operator cast(file);
string operator cast(file);
string[] operator cast(file);
string[][] operator cast(file);
string[][][] operator cast(file);
guide operator cast(cycleToken tok);
guide operator cast(curlSpecifier spec);
guide operator cast(tensionSpecifier t);
pair operator cast(pairOrTriple a);
triple operator cast(pairOrTriple a);
guide[] operator cast(path[] g);
object operator cast(Label L);
pair operator cast(position P);
position operator cast(int x);
bool operator cast(bool3 b);
bool3 operator cast(bool b);
position operator cast(real x);
guide[] operator cast(pair[] z);
path[] operator cast(guide[] g);
object operator cast(frame f);
hsv operator cast(pen p);
path[] operator cast(guide g);
position operator cast(pair x);
path[] operator cast(pair[] z);
path[] operator cast(path p);
align operator cast(pair dir);
Label operator cast(string s);
bool3[] operator cast(bool[] b);
align operator cast(triple dir);
bool[] operator cast(bool3[] b);
object operator cast(string s);
align operator cast(side side);
Label operator cast(object F);
frame operator cast(object F);
pen operator cast(hsv hsv);
pen deepred;
bool error(file f);
string operator ecast(int);
string operator ecast(real);
string operator ecast(pair);
string operator ecast(triple);
int operator ecast(string);
real operator ecast(string);
pair operator ecast(string);
triple operator ecast(string);
int operator ecast(real);
int[] operator ecast(real[]);
real[] operator ecast(string[] a);
int[] operator ecast(string[] a);
bool operator init();
int operator init();
real operator init();
string operator init();
pair operator init();
triple operator init();
transform operator init();
guide operator init();
path operator init();
path3 operator init();
pen operator init();
frame operator init();
file operator init();
slice operator init();
filltype operator init();
Legend operator init();
picture operator init();
side operator init();
position operator init();
realschur operator init();
bool3 operator init();
bounds operator init();
light operator init();
autoscaleT operator init();
ScaleT operator init();
align operator init();
cputime operator init();
marginT operator init();
transformation operator init();
projection operator init();
coords3 operator init();
Label operator init();
marker operator init();
coords2 operator init();
node operator init();
object operator init();
processtime operator init();
hsv operator init();
coord operator init();
scaleT operator init();
arrowhead operator init();
scaling operator init();
pairOrTriple operator init();
schur operator init();
real animationdelay;
frame NoBox(frame f);
animation operator init();
frame BBox(frame)(real xmargin=<default>, real ymargin=<default>, pen p=<default>, filltype filltype=<default>);
void annotate(picture pic=<default>, string title, string text, pair position);
void babel(string s);
bool isDuplicate(pair a, pair b, real relSize);
real maxrefinements;
private real[][] intersections(pair a, pair b, path p);
path[] bezulate(path[] p);
path[][] containmentTree(path[] paths);
path section(path p, real t1, real t2, bool loop=<default>);
path removeDuplicates(path p);
void connect(path[] paths, path[] result, path[] patch);
bool checkSegment(path g, pair p, pair q);
path uncycle(path p, real t);
int countIntersections(path[] p, pair start, pair end);
real duplicateFuzz;
path subdivide(path p);
private real fuzz;
key nil;
real minDistDefault;
binarytreeNode binarytreeNode(int key);
real nodeMarginDefault;
binarytree binarytree(... key[] keys);
key key(int n, bool active=<default>);
key operator cast(int n);
int operator cast(key k);
int[] operator cast(key[] k);
binarytree searchtree(... int[] keys);
binarytreeNode operator init();
object draw(picture pic=<default>, binarytreeNode node, pair pos, int height, real minDist, real levelDist, real nodeDiameter, pen p=<default>, bool condensed=<default>);
void draw(picture pic=<default>, binarytree tree, real minDist=<default>, real nodeMargin=<default>, pen p=<default>, bool condensed=<default>);
real epsilon;
private line intersection(face a, face b);
picture operator cast(face f);
face operator cast(path3 p);
void add(picture pic=<default>, face[] faces, projection P=<default>);
splitface split(face a, face cut, projection P);
list_data viridis;
seg_data wistia;
seg_data winter;
list_data tab20c;
list_data seismic;
seg_data nipy_spectral;
seg_data hot;
seg_data gist_stern;
seg_data gist_ncar;
seg_data gist_earth;
seg_data copper;
seg_data cool;
list_data bwr;
list_data brg;
seg_data binary;
list_data YlOrRd;
list_data YlGn;
list_data Set2;
list_data Reds;
list_data RdYlGn;
list_data cividis;
list_data PRGn;
list_data inferno;
list_data RdPu;
list_data tab20;
seg_data summer;
seg_data gray;
list_data tab20b;
list_data plasma;
seg_data spring;
seg_data autumn;
list_data Paired;
seg_data hsv;
list_data RdBu;
seg_data bone;
list_data tab10;
list_data Pastel1;
list_data Greys;
list_data twilight_shifted;
seg_data coolwarm;
private real[] makeMappingArray(int N, triple[] data, real gamma=<default>);
list_data Spectral;
list_data Purples;
list_data Greens;
list_data Set1;
list_data Set3;
seg_data pink;
list_data magma;
list_data YlGnBu;
list_data BrBG;
list_data OrRd;
list_data twilight;
list_data PuRd;
list_data PuBuGn;
list_data RdGy;
list_data YlOrBr;
list_data Pastel2;
seg_data jet;
list_data Accent;
list_data Blues;
list_data BuGn;
list_data BuPu;
seg_data CMRmap;
list_data Dark2;
list_data GnBu;
list_data Oranges;
list_data PiYG;
list_data PuBu;
list_data PuOr;
list_data RdYlBu;
real eps;
surface surface(vertex[][] g);
vertex[][] contour3(triple[][][] v, real[][][] f, real[][][] midpoint=<default>, projection P=<default>);
vertex[][] contour3(real[][][] f, real[][][] midpoint=<default>, triple a, triple b, projection P=<default>);
vertex[][] contour3(real f(real, real, real), triple a, triple b, int nx=<default>, int ny=<default>, int nz=<default>, projection P=<default>);
private segment case3(pair p0, pair p1, pair p2, real v0, real v1, real v2, int edge=<default>);
private segment case1(pair p0, pair p1, int edge);
real eps;
private segment case2(pair p0, pair p1, pair p2, real v0, real v1, real v2, int edge);
pen[][] interior(picture pic=<default>, guide[][] g, pen[] palette);
guide[][] contour(picture pic=<default>, pair[][] z, real[][] f, real[][] midpoint=<default>, real[] c, guide join(... guide[])=<default>);
guide[][] contour(picture pic=<default>, real[][] f, real[][] midpoint=<default>, pair a, pair b, real[] c, guide join(... guide[])=<default>);
guide[][] contour(picture pic=<default>, real f(real, real), pair a, pair b, real[] c, int nx=<default>, int ny=<default>, guide join(... guide[])=<default>);
guide[][] contour(picture pic=<default>, real f(pair), pair a, pair b, real[] c, int nx=<default>, int ny=<default>, guide join(... guide[])=<default>);
guide[][] contour(picture pic=<default>, pair[] z, real[] f, real[] c, guide join(... guide[])=<default>);
private guide[][] connect(picture pic, pair[][][] points, real[] c, guide join(... guide[]));
private void addseg(pair[][] gds, segment seg);
private void collect(pair[][][] points, real[] c);
void draw(picture pic=<default>, Label[] L=<default>, guide[][] g, pen[] p);
void draw(picture pic=<default>, Label[] L=<default>, guide[][] g, pen p=<default>);
void fill(picture pic=<default>, guide[][] g, pen[][] palette);
pen[] extend(pen[] palette, pen below, pen above);
private segment checktriangle(pair p0, pair p1, pair p2, real v0, real v1, real v2, int edge=<default>);
void drawAll(TreeNode node, frame f);
real layout(int level, TreeNode node);
real treeMinNodeWidth;
real treeLevelStep;
void add(TreeNode child, TreeNode parent);
void draw(TreeNode root, pair pos);
TreeNode makeNode(TreeNode parent=<default>, frame f);
TreeNode makeNode(TreeNode parent=<default>, Label label);
real treeNodeStep;
string embed(string name, string text=<default>, string options=<default>, real width=<default>, real height=<default>);
string embedplayer(string name, string text=<default>, string options=<default>, real width=<default>, real height=<default>);
string link(string label, string text=<default>);
string hyperlink(string url, string text);
string embed(string name, string text=<default>, string options=<default>, real width=<default>, real height=<default>, string image=<default>);
string link(string label, string text=<default>);
void texshipout(string stem, picture pic=<default>, bool xalign=<default>);
void fmdefaults();
void drawMomArrow(picture pic=<default>, path p, align align, position pos=<default>, real offset=<default>, real length=<default>, pen fgpen=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool erasebg=<default>, pen bgpen=<default>, real margin=<default>);
void drawVertexOX(picture pic=<default>, pair xy, real r=<default>, pen fgpen=<default>, bool erasebg=<default>, pen bgpen=<default>);
void drawVertexX(picture pic=<default>, pair xy, real r=<default>, pen fgpen=<default>);
void drawVertexBoxO(picture pic=<default>, pair xy, real r=<default>, pen fgpen=<default>, bool erasebg=<default>, pen bgpen=<default>);
void drawVertexBox(picture pic=<default>, pair xy, real r=<default>, pen fgpen=<default>);
void drawVertexTriangleO(picture pic=<default>, pair xy, real r=<default>, pen fgpen=<default>, bool erasebg=<default>, pen bgpen=<default>);
void drawVertexTriangle(picture pic=<default>, pair xy, real r=<default>, pen fgpen=<default>);
void drawVertexO(picture pic=<default>, pair xy, real r=<default>, pen fgpen=<default>, bool erasebg=<default>, pen bgpen=<default>);
void drawVertex(picture pic=<default>, pair xy, real r=<default>, pen fgpen=<default>);
void drawGhost(picture pic=<default>, path p, pen fgpen=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool erasebg=<default>, pen bgpen=<default>, real vertexangle=<default>, real margin=<default>);
void drawFermion(picture pic=<default>, path p, pen fgpen=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool erasebg=<default>, pen bgpen=<default>, real vertexangle=<default>, real margin=<default>);
void drawPhoton(picture pic=<default>, path p, real amp=<default>, real width=<default>, pen fgpen=<default>, bool erasebg=<default>, pen bgpen=<default>, real vertexangle=<default>, real margin=<default>);
void drawGluon(picture pic=<default>, path p, real amp=<default>, real width=<default>, pen fgpen=<default>, bool erasebg=<default>, pen bgpen=<default>, real vertexangle=<default>, real margin=<default>);
path momArrowPath(path p, align align, position pos, real offset=<default>, real length=<default>);
path photon(path p, real amp=<default>, real width=<default>);
private void do_overpaint(picture pic, path p, pen bgpen, real halfwidth, real vertexangle);
void drawVertexBoxX(picture pic=<default>, pair xy, real r=<default>, pen fgpen=<default>, bool erasebg=<default>, pen bgpen=<default>);
path gluon(path p, real amp=<default>, real width=<default>);
void drawDoubleLine(picture pic=<default>, path p, pen fgpen=<default>, real dlspacing=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool erasebg=<default>, pen bgpen=<default>, real vertexangle=<default>, real margin=<default>);
pen photonpen;
bool overpaint;
real momarrowoffset;
bool DoubleLineMidArrow(picture, path, pen, marginT(path, pen));
bool currentarrow(picture, path, pen, marginT(path, pen));
real momarrowsize(pen p=<default>);
real gluonratio;
pen vertexpen;
bool currentmomarrow(picture, path, pen, marginT(path, pen));
bool XYAlign;
real bigvertexsize;
real vertexsize;
bool YAlign;
pen momarrowpen;
pen bigvertexpen;
string includegraphicscommand;
real linemargin;
real gluonamplitude;
real photonratio;
real photonamplitude;
pen backgroundpen;
void drawScalar(picture pic=<default>, path p, pen fgpen=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool erasebg=<default>, pen bgpen=<default>, real vertexangle=<default>, real margin=<default>);
pen gluonpen;
pen fermionpen;
pen scalarpen;
pen ghostpen;
pen doublelinepen;
real momarrowmargin;
real doublelinespacing;
real momarrowfactor;
real minvertexangle;
real momarrowlength;
bool appendsuffix;
Dir Down;
Dir Up;
Dir Left;
Dir Right;
block blockconnector(block, block)(picture pic, transform t, pen p=<default>, marginT margin(path, pen)=<default>);
path path(pair[] point, ... flowdir[] dir);
block bevel(object body, pair center=<default>, pen fillpen=<default>, pen drawpen=<default>, real dh=<default>, real dw=<default>, real minwidth=<default>, real minheight=<default>);
block roundrectangle(object body, pair center=<default>, pen fillpen=<default>, pen drawpen=<default>, real ds=<default>, real dw=<default>, real minwidth=<default>, real minheight=<default>);
block parallelogram(object body, pair center=<default>, pen fillpen=<default>, pen drawpen=<default>, real dx=<default>, real slope=<default>, real minwidth=<default>, real minheight=<default>);
real defaultexcursion;
real minblockheight;
real minblockwidth;
restricted flowdir Horizontal;
block operator --(block b1, Label label);
block operator --(block b1, Dir dir);
block operator --(block b, bool arrowbar(picture, path, pen, marginT(path, pen)));
void draw(picture pic=<default>, block block, pen p=<default>);
real mincirclediameter;
restricted flowdir Vertical;
block circle(object body, pair center=<default>, pen fillpen=<default>, pen drawpen=<default>, real dr=<default>, real mindiameter=<default>);
block diamond(object body, pair center=<default>, pen fillpen=<default>, pen drawpen=<default>, real ds=<default>, real dw=<default>, real height=<default>, real minwidth=<default>, real minheight=<default>);
block rectangle(object header, object body, pair center=<default>, pen headerpen=<default>, pen bodypen=<default>, pen drawpen=<default>, real dx=<default>, real minheaderwidth=<default>, real minheaderheight=<default>, real minbodywidth=<default>, real minbodyheight=<default>);
block rectangle(object body, pair center=<default>, pen fillpen=<default>, pen drawpen=<default>, real dx=<default>, real minwidth=<default>, real minheight=<default>);
line tangent(circle c, abscissa x);
line tangent(circle c, point M);
line tangent(circle c, explicit vector v);
line tangent(ellipse el, abscissa x);
line tangent(parabola p, abscissa x);
line tangent(hyperbola h, abscissa x);
line tangent(explicit arc a, abscissa x);
line tangent(explicit arc a, point M);
point radicalcenter(circle c1, circle c2);
point radicalcenter(circle c1, circle c2, circle c3);
inversion inversion(circle c1, circle c2, real sgn=<default>);
inversion inversion(circle c1, circle c2, circle c3);
inversion inversion(circle c);
triangle anticomplementary(triangle t);
triangle symmedial(triangle t);
triangle orthic(triangle t);
line median(vertex V);
line median(side side);
point intouch(side side);
triangle intouch(triangle t);
triangle incentral(triangle t);
triangle antipedal(triangle t, point M);
point isogonalconjugate(triangle t, point M);
point[] fermat(triangle t);
point gergonne(triangle t);
point symmedian(triangle t);
point symmedian(side side);
line symmedian(vertex V);
trilinear trilinear(triangle t, real a, real b, real c);
trilinear trilinear(triangle t, point M);
trilinear trilinear(triangle t, real f(real, real, real), real a=<default>, real b=<default>, real c=<default>);
point foot(vertex V);
point foot(side side);
triangle triangleabc(real a, real b, real c, real angle=<default>, point A=<default>);
circle excircle(point A, point B, point C);
circle excircle(side side);
real exradius(point A, point B, point C);
real exradius(side side);
point excenter(point A, point B, point C);
point excenter(side side);
circle incircle(point A, point B, point C);
circle incircle(triangle t);
real inradius(point A, point B, point C);
real inradius(triangle t);
point orthocenter(point A, point B, point C);
point orthocenter(triangle t);
mass masscenter(... mass[] M);
int arcnodesnumber(explicit arc a);
point curpoint(line l, real x);
point curpoint(explicit circle c, real x);
point curpoint(explicit ellipse el, real x);
point curpoint(explicit parabola p, real x);
point curpoint(conic co, real x);
point curpoint(arc a, real x);
abscissa nodabscissa(real x);
abscissa nodabscissa(int x);
abscissa nodabscissa(line l, point M);
abscissa nodabscissa(circle c, point M);
abscissa nodabscissa(ellipse el, point M);
abscissa nodabscissa(parabola p, point M);
abscissa nodabscissa(conic co, point M);
abscissa nodabscissa(arc a, point M);
abscissa angabscissa(real x, path polarconicroutine(conic co, real angle1, real angle2, int n, bool direction)=<default>);
abscissa angabscissa(int x, path polarconicroutine(conic co, real angle1, real angle2, int n, bool direction)=<default>);
abscissa angabscissa(circle c, point M);
abscissa angabscissa(ellipse el, point M, path polarconicroutine(conic co, real angle1, real angle2, int n, bool direction)=<default>);
abscissa angabscissa(hyperbola h, point M, path polarconicroutine(conic co, real angle1, real angle2, int n, bool direction)=<default>);
abscissa angabscissa(parabola p, point M);
abscissa angabscissa(explicit conic co, point M);
abscissa angabscissa(arc a, point M);
abscissa curabscissa(real x);
abscissa curabscissa(int x);
abscissa curabscissa(line l, point M);
abscissa curabscissa(circle c, point M);
abscissa curabscissa(ellipse el, point M);
abscissa curabscissa(parabola p, point M);
abscissa curabscissa(conic co, point M);
abscissa curabscissa(arc a, point M);
abscissa relabscissa(real x);
abscissa relabscissa(int x);
abscissa relabscissa(line l, point M);
abscissa relabscissa(circle c, point M);
abscissa relabscissa(ellipse el, point M);
abscissa relabscissa(conic co, point M);
abscissa relabscissa(arc a, point M);
restricted int relativesystem;
bqe canonical(bqe bqe);
real[] bangles(picture pic=<default>, parabola p);
real[][] bangles(picture pic=<default>, hyperbola h);
restricted path fromFocus(conic co, real angle1, real angle2, int n, bool direction);
real operator ^(point M, explicit circle c);
point circumcenter(point A, point B, point C);
point circumcenter(triangle t);
parabola parabola(point F, line l);
parabola parabola(point F, point vertex);
parabola parabola(point F, real a, real angle);
parabola parabola(bqe bqe);
parabola parabola(point M1, point M2, point M3, line l);
parabola parabola(point M1, point M2, point M3, point M4, point M5);
real focusToCenter(ellipse el, real a);
path arcfromcenter(ellipse el, real angle1, real angle2, bool direction=<default>, int n=<default>);
path arcfromcenter(hyperbola h, real angle1, real angle2, int n=<default>, bool direction=<default>);
path arcfromcenter(explicit conic co, real angle1, real angle2, int n, bool direction=<default>);
hyperbola hyperbola(point P1, point P2, real ae, bool byfoci=<default>);
hyperbola hyperbola(point F1, point F2, point M);
hyperbola hyperbola(point C, real a, real b, real angle=<default>);
hyperbola hyperbola(bqe bqe);
hyperbola hyperbola(point M1, point M2, point M3, point M4, point M5);
coordsys canonicalcartesiansystem(ellipse el);
coordsys canonicalcartesiansystem(parabola p);
coordsys canonicalcartesiansystem(hyperbola h);
coordsys canonicalcartesiansystem(explicit conic co);
point angpoint(conic co, real angle);
point angpoint(explicit circle c, real x);
point angpoint(explicit ellipse el, real x, path polarconicroutine(conic co, real angle1, real angle2, int n, bool direction)=<default>);
point angpoint(explicit parabola p, real x);
point angpoint(explicit hyperbola h, real x, path polarconicroutine(conic co, real angle1, real angle2, int n, bool direction)=<default>);
point angpoint(arc a, real angle);
path currentpolarconicroutine(conic co, real angle1, real angle2, int n, bool direction);
int hyperbolanodesnumber(hyperbola h, real angle1, real angle2);
int parabolanodesnumber(parabola p, real angle1, real angle2);
int parabolanodesnumberfactor;
real centerToFocus(ellipse el, real a);
int ellipsenodesnumberfactor;
int circlenodesnumberfactor;
line sector(int n=<default>, int p=<default>, line l1, line l2, real angle=<default>, bool sharp=<default>);
real sharpangle(line l1, line l2);
line perpendicular(point M, line l);
line perpendicular(point M, explicit vector normal);
line perpendicular(point M, explicit pair normal);
bool perpendicular(line l1, line l2);
void perpendicular(picture pic=<default>, pair z, pair align, pair dir=<default>, real size=<default>, pen p=<default>, marginT margin(path, pen)=<default>, filltype filltype=<default>);
void perpendicular(picture pic=<default>, pair z, pair align, path g, real size=<default>, pen p=<default>, marginT margin(path, pen)=<default>, filltype filltype=<default>);
transform hprojection(line l, bool safe=<default>);
line parallel(point M, line l);
line parallel(point M, explicit vector dir);
line parallel(point M, explicit pair dir);
bool parallel(line l1, line l2, bool strictly=<default>);
transform reflect(line l);
transform reflect(line l1, line l2, bool safe=<default>);
line hline(coordsys R=<default>);
line hline;
line vline(coordsys R=<default>);
restricted line vline;
line Oy(coordsys R=<default>);
restricted line Oy;
line Ox(coordsys R=<default>);
restricted line Ox;
line extend(line l);
coordsys coordsys(line l);
coordsys coordsys(conic co);
coordsys coordsys(ellipse el);
bool operator @(point m, line l);
bool operator @(point M, conic co);
bool operator @(point M, explicit circle c);
bool operator @(point M, arc a);
line line(point A, bool extendA=<default>, point B, bool extendB=<default>);
line line(segment s);
line line(real a, point A=<default>);
line line(point A=<default>, real a);
line line(int a, point A=<default>);
line line(coordsys R=<default>, real slope, real origin);
line line(coordsys R=<default>, real a, real b, real c);
line line(circle c);
line line(explicit side side);
pair attract(pair m, path g, real fuzz=<default>);
point attract(point M, path g, real fuzz=<default>);
void distance(picture pic=<default>, Label L=<default>, point A, point B, bool rotated=<default>, real offset=<default>, pen p=<default>, pen joinpen=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>);
real distance(point M, line l);
real distance(line l, point M);
void clipdraw(picture pic=<default>, Label L=<default>, path g, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool bar(picture, path, pen, marginT(path, pen))=<default>, real xmargin=<default>, real ymargin=<default>, Label legend=<default>, marker marker=<default>);
private void Drawline(picture pic=<default>, Label L=<default>, pair P, bool dirP=<default>, pair Q, bool dirQ=<default>, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, Label legend=<default>, marker marker=<default>, path pathModifier(path)=<default>);
bool defined(point P);
pen addpenarc;
pen addpenarc(pen p);
point origin;
point origin(coordsys R=<default>);
vector unit(point M);
vector unit(vector u);
real perpfactor;
bool collinear(vector u, vector v);
vector vector(coordsys R=<default>, pair v);
vector vector(point M);
transform xscaleO(real x);
transform scaleO(real x);
transform yscale(real k, point M);
transform rotateO(real a);
bool Finite(explicit point z);
point conj(explicit point M);
vector conj(explicit vector u);
hyperbola conj(hyperbola h);
real abs(coordsys R, pair m);
real abs(explicit point M);
point operator -(explicit point P);
point operator -(explicit point P1, explicit point P2);
point operator -(explicit point P1, explicit pair p2);
point operator -(explicit pair p1, explicit point P2);
point operator -(point M, explicit vector v);
vector operator -(explicit vector v);
point operator -(explicit pair m, explicit vector v);
vector operator -(explicit vector v1, explicit vector v2);
line operator -(line l, vector u);
conic operator -(conic c, explicit point M);
conic operator -(conic c, explicit pair m);
conic operator -(conic c, vector v);
circle operator -(explicit circle c, explicit point M);
circle operator -(explicit circle c, pair m);
circle operator -(explicit circle c, vector m);
abscissa operator -(explicit abscissa a);
abscissa operator -(real x, explicit abscissa a);
abscissa operator -(explicit abscissa a, real x);
abscissa operator -(int x, explicit abscissa a);
arc operator -(explicit arc a, point M);
arc operator -(explicit arc a, vector v);
mass operator -(mass M1, mass M2);
mass operator -(explicit mass M, real x);
mass operator -(explicit mass M, int x);
pair locate(point P);
point locate(pair p);
pair locate(explicit vector v);
coordsys currentcoordsys;
restricted coordsys defaultcoordsys;
real EPS;
real binomial(real n, real k);
real Infinity;
void markangle(picture pic=<default>, Label L=<default>, int n=<default>, real radius=<default>, real space=<default>, explicit line l1, explicit line l2, explicit pair align=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, pen p=<default>, filltype filltype=<default>, marginT margin(path, pen)=<default>, marker marker=<default>);
void markangle(picture pic=<default>, Label L=<default>, int n=<default>, real radius=<default>, real space=<default>, explicit line l1, explicit line l2, explicit vector align, bool arrow(picture, path, pen, marginT(path, pen))=<default>, pen p=<default>, filltype filltype=<default>, marginT margin(path, pen)=<default>, marker marker=<default>);
pair coordinates(point M);
triangle triangleAbc(real alpha, real b, real c, real angle=<default>, point A=<default>);
restricted int angularsystem;
string massformat(string format=<default>, string s, mass M);
conic conic(point F, line l, real e);
conic conic(point M1, point M2, point M3, point M4, point M5);
conic conic(bqe bqe);
transform scale(real k, point M);
transform scale(real k, point A, point B, point C, point D, bool safe=<default>);
transform scale(real k, line l1, line l2, bool safe=<default>);
point changecoordsys(coordsys R, point M);
vector changecoordsys(coordsys R, vector v);
line changecoordsys(coordsys R, line l);
bqe changecoordsys(coordsys R, bqe bqe);
conic changecoordsys(coordsys R, conic co);
int conicnodesfactor;
point isotomicconjugate(triangle t, point M);
bool between(point M, point O, point N);
point operator +(explicit point P1, explicit point P2);
point operator +(explicit point P1, explicit pair p2);
point operator +(explicit pair p1, explicit point p2);
point operator +(point M, explicit vector v);
point operator +(explicit pair m, explicit vector v);
vector operator +(explicit vector v1, explicit vector v2);
line operator +(line l, vector u);
conic operator +(conic c, explicit point M);
conic operator +(conic c, explicit pair m);
conic operator +(conic c, vector v);
circle operator +(explicit circle c, explicit point M);
circle operator +(explicit circle c, pair m);
circle operator +(explicit circle c, vector m);
abscissa operator +(real x, explicit abscissa a);
abscissa operator +(explicit abscissa a, real x);
abscissa operator +(int x, explicit abscissa a);
arc operator +(explicit arc a, point M);
arc operator +(explicit arc a, vector v);
mass operator +(mass M1, mass M2);
mass operator +(explicit mass M, real x);
mass operator +(explicit mass M, int x);
void markrightangle(picture pic=<default>, point A, point O, point B, real size=<default>, pen p=<default>, marginT margin(path, pen)=<default>, filltype filltype=<default>);
point arcsubtendedcenter(point A, point B, real angle);
real rd(real x, real y, real z);
line radicalline(circle c1, circle c2);
vector dir(vertex V);
coordsys cartesiansystem(pair O=<default>, pair i, pair j);
line bisector(line l1, line l2, real angle=<default>, bool sharp=<default>);
line bisector(point A, point B, point C, point D, real angle=<default>, bool sharp=<default>);
line bisector(segment s, real angle=<default>);
line bisector(point A, point B, real angle=<default>);
line bisector(vertex V, real angle=<default>);
line bisector(side side);
triangle pedal(triangle t, point M);
line pedal(side side, point M);
real length(explicit point M);
real length(segment s);
arc arc(ellipse el, real angle1, real angle2, path polarconicroutine(conic co, real angle1, real angle2, int n, bool direction)=<default>, bool direction=<default>);
arc arc(ellipse el, explicit abscissa x1, explicit abscissa x2, bool direction=<default>);
arc arc(ellipse el, point M, point N, bool direction=<default>);
arc arc(explicit arc a, abscissa x1, abscissa x2);
arc arc(explicit arc a, point M, point N);
path arc(explicit pair B, explicit pair A, explicit pair C, real r);
int sgnd(real x);
int sgnd(int x);
point inverse(inversion i, point P);
circle inverse(inversion i, line l);
circle inverse(inversion i, circle c);
arc inverse(inversion i, segment s);
pair[] intersectionpoints(pair A, pair B, real a, real b, real c, real d, real f, real g);
pair[] intersectionpoints(pair A, pair B, real[] equation);
point[] intersectionpoints(line l, path g);
point[] intersectionpoints(triangle t, line l, bool extended=<default>);
point[] intersectionpoints(line l, triangle t, bool extended=<default>);
point[] intersectionpoints(line l, circle c);
point[] intersectionpoints(circle c, line l);
point[] intersectionpoints(line l, ellipse el);
point[] intersectionpoints(ellipse el, line l);
point[] intersectionpoints(line l, parabola p);
point[] intersectionpoints(parabola p, line l);
point[] intersectionpoints(line l, hyperbola h);
point[] intersectionpoints(hyperbola h, line l);
point[] intersectionpoints(line l, conic co);
point[] intersectionpoints(conic co, line l);
point[] intersectionpoints(bqe bqe1, bqe bqe2);
point[] intersectionpoints(conic co1, conic co2);
point[] intersectionpoints(triangle t, conic co, bool extended=<default>);
point[] intersectionpoints(conic co, triangle t, bool extended=<default>);
point[] intersectionpoints(ellipse a, ellipse b);
point[] intersectionpoints(ellipse a, circle b);
point[] intersectionpoints(circle a, ellipse b);
point[] intersectionpoints(ellipse a, parabola b);
point[] intersectionpoints(parabola a, ellipse b);
point[] intersectionpoints(ellipse a, hyperbola b);
point[] intersectionpoints(hyperbola a, ellipse b);
point[] intersectionpoints(circle a, parabola b);
point[] intersectionpoints(parabola a, circle b);
point[] intersectionpoints(circle a, hyperbola b);
point[] intersectionpoints(hyperbola a, circle b);
point[] intersectionpoints(parabola a, parabola b);
point[] intersectionpoints(parabola a, hyperbola b);
point[] intersectionpoints(hyperbola a, parabola b);
point[] intersectionpoints(hyperbola a, hyperbola b);
point[] intersectionpoints(circle c1, circle c2);
point[] intersectionpoints(conic co, arc a);
point[] intersectionpoints(arc a, conic co);
point[] intersectionpoints(arc a1, arc a2);
point[] intersectionpoints(line l, arc a);
point[] intersectionpoints(arc a, line l);
point[] standardizecoordsys(coordsys R=<default>, bool warn=<default>, ... point[] M);
bool finite(explicit point p);
transform vprojection(line l, bool safe=<default>);
triangle medial(triangle t);
private int[] numarray;
point point(coordsys R, pair p, real m=<default>);
point point(explicit pair p, real m);
point point(coordsys R, explicit point M, real m=<default>);
point point(explicit vector u);
point point(circle c, abscissa l);
point point(ellipse el, abscissa l);
point point(parabola p, abscissa l);
point point(hyperbola h, abscissa l);
point point(explicit conic co, abscissa l);
point point(line l, abscissa x);
point point(line l, explicit real x);
point point(line l, explicit int x);
point point(explicit circle c, explicit real x);
point point(explicit circle c, explicit int x);
point point(explicit ellipse el, explicit real x);
point point(explicit ellipse el, explicit int x);
point point(explicit parabola p, explicit real x);
point point(explicit parabola p, explicit int x);
point point(explicit hyperbola h, explicit real x);
point point(explicit hyperbola h, explicit int x);
point point(explicit conic co, explicit real x);
point point(explicit conic co, explicit int x);
point point(arc a, abscissa l);
point point(arc a, real x);
pair point(explicit arc a, int x);
point point(explicit mass m);
point point(explicit vertex V);
point point(trilinear tri);
point point(circle c, point M);
point point(circle c, explicit vector v);
restricted bool byfoci;
line isotomic(vertex V, point M);
point isotomic(side side, point M);
triangle isotomic(triangle t, point M);
int hyperbolanodesnumberfactor;
int ellipsenodesnumber(real a, real b);
int ellipsenodesnumber(real a, real b, real angle1, real angle2, bool dir);
void addMargins(picture pic=<default>, real lmargin=<default>, real bmargin=<default>, real rmargin=<default>, real tmargin=<default>, bool rigid=<default>, bool allObject=<default>);
bool simeq(point A, point B, real fuzz=<default>);
bool simeq(point a, real b, real fuzz=<default>);
line reverse(line l);
arc reverse(arc a);
real arclength(circle c);
real arclength(ellipse el);
real arclength(ellipse el, real angle1, real angle2, bool direction=<default>, path polarconicroutine(conic co, real angle1, real angle2, int n, bool direction)=<default>);
real arclength(parabola p, real angle);
real arclength(parabola p, real angle1, real angle2);
real arclength(parabola p);
real arclength(arc a);
void show(picture pic=<default>, Label lo=<default>, Label li=<default>, Label lj=<default>, coordsys R, pen dotpen=<default>, pen xpen=<default>, pen ypen=<default>, pen ipen=<default>, pen jpen=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>);
void show(Label L, vector v, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>);
void show(picture pic=<default>, line l, pen p=<default>);
void show(picture pic=<default>, Label LA=<default>, Label LB=<default>, Label LC=<default>, Label La=<default>, Label Lb=<default>, Label Lc=<default>, triangle t, pen p=<default>, filltype filltype=<default>);
triangle triangle(line l1, line l2, line l3);
void draw(picture pic=<default>, Label L=<default>, line l, bool dirA=<default>, bool dirB=<default>, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, Label legend=<default>, marker marker=<default>, path pathModifier(path)=<default>);
void draw(picture pic=<default>, Label[] L=<default>, line[] l, align align=<default>, pen[] p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, Label[] legend=<default>, marker marker=<default>, path pathModifier(path)=<default>);
void draw(picture pic=<default>, Label[] L=<default>, line[] l, align align=<default>, pen p, bool arrow(picture, path, pen, marginT(path, pen))=<default>, Label[] legend=<default>, marker marker=<default>, path pathModifier(path)=<default>);
void draw(picture pic=<default>, Label L=<default>, circle c, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool bar(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, Label legend=<default>, marker marker=<default>);
void draw(picture pic=<default>, Label L=<default>, ellipse el, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool bar(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, Label legend=<default>, marker marker=<default>);
void draw(picture pic=<default>, Label L=<default>, parabola parabola, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool bar(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, Label legend=<default>, marker marker=<default>);
void draw(picture pic=<default>, Label L=<default>, hyperbola h, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool bar(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, Label legend=<default>, marker marker=<default>);
void draw(picture pic=<default>, Label L=<default>, explicit conic co, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool bar(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, Label legend=<default>, marker marker=<default>);
void draw(picture pic=<default>, Label L=<default>, arc a, align align=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, bool bar(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, Label legend=<default>, marker marker=<default>);
void draw(picture pic=<default>, triangle t, pen p=<default>, marker marker=<default>);
void draw(picture pic=<default>, triangle[] ts, pen p=<default>, marker marker=<default>);
point midpoint(segment s);
point midpoint(side side);
void label(picture pic=<default>, Label L, explicit mass M, align align=<default>, string format=<default>, pen p=<default>, filltype filltype=<default>);
void label(picture pic=<default>, Label L, vertex V, pair align=<default>, real alignFactor=<default>, pen p=<default>, filltype filltype=<default>);
void label(picture pic=<default>, Label LA=<default>, Label LB=<default>, Label LC=<default>, triangle t, real alignAngle=<default>, real alignFactor=<default>, pen p=<default>, filltype filltype=<default>);
arc arcsubtended(point A, point B, real angle);
line[] operator ^^(line l1, line l2);
line[] operator ^^(line l1, line[] l2);
line[] operator ^^(line[] l2, line l1);
line[] operator ^^(line[] l1, line[] l2);
triangle[] operator ^^(triangle[] t1, triangle t2);
triangle[] operator ^^(... triangle[] t);
point relpoint(line l, real x);
point relpoint(explicit circle c, real x);
point relpoint(explicit ellipse el, real x);
point relpoint(explicit parabola p, real x);
point relpoint(explicit hyperbola h, real x);
point relpoint(explicit conic co, explicit real x);
point relpoint(explicit conic co, explicit int x);
point relpoint(arc a, real x);
bool onpath(picture pic=<default>, path g, point M, pen p=<default>);
bqe bqe(coordsys R=<default>, real a, real b, real c, real d, real e, real f);
bqe bqe(point M1, point M2, point M3, point M4, point M5);
path arcfromfocus(conic co, real angle1, real angle2, int n=<default>, bool direction=<default>);
string conictype(bqe bqe);
void fill(picture pic=<default>, circle c, pen p=<default>);
void fill(picture pic=<default>, ellipse el, pen p=<default>);
void fill(picture pic=<default>, triangle t, pen p=<default>);
void fill(picture pic=<default>, triangle[] ts, pen p=<default>);
segment segment(point A, point B);
segment segment(line l);
segment segment(explicit side side);
int circlenodesnumber(real r);
int circlenodesnumber(real r, real angle1, real angle2);
line[] tangents(circle c, point M);
line[] tangents(ellipse el, point M);
line[] tangents(parabola p, point M);
line[] tangents(hyperbola h, point M);
bool sameside(point M, point N, point O);
bool sameside(point M, point P, line l);
point[] sameside(point M, line l1, line l2);
private path arctopath(arc a, int n);
void write(explicit line l);
void write(explicit segment s);
void write(trilinear tri);
pair operator cast(point P);
pair[] operator cast(point[] P);
point operator cast(pair p);
point[] operator cast(pair[] p);
guide operator cast(point p);
path operator cast(point p);
point operator cast(vector v);
vector operator cast(pair v);
vector operator cast(explicit point v);
pair operator cast(explicit vector v);
align operator cast(vector v);
line operator cast(segment s);
segment operator cast(line l);
ellipse operator cast(circle c);
conic operator cast(parabola p);
conic operator cast(hyperbola h);
conic operator cast(ellipse el);
conic operator cast(circle c);
path operator cast(ellipse el);
path operator cast(circle c);
path operator cast(parabola p);
path operator cast(hyperbola h);
path operator cast(conic co);
abscissa operator cast(explicit position position);
abscissa operator cast(real x);
abscissa operator cast(int x);
path operator cast(explicit arc a);
guide operator cast(explicit arc a);
point operator cast(mass m);
mass operator cast(point M);
point[] operator cast(mass[] m);
mass[] operator cast(point[] P);
mass operator cast(pair m);
path operator cast(mass M);
guide operator cast(mass M);
path operator cast(triangle t);
line operator cast(side side);
point operator cast(vertex V);
point operator cast(trilinear tri);
circle operator cast(inversion i);
inversion operator cast(circle c);
bool inside(ellipse el, point M);
bool inside(parabola p, point M);
real[] realquarticroots(real a, real b, real c, real d, real e);
line complementary(explicit line l);
line[] complementary(explicit segment s);
arc complementary(arc a);
triangle cevian(triangle t, point P);
point cevian(side side, point P);
line cevian(vertex V, point P);
pair operator *(coordsys R, pair p);
path operator *(coordsys R, path g);
coordsys operator *(transform t, coordsys R);
point operator *(real x, explicit point P);
point operator *(transform t, explicit point P);
point operator *(explicit point P1, explicit point P2);
point operator *(explicit point P1, explicit pair p2);
point operator *(explicit pair p1, explicit point p2);
vector operator *(real x, explicit vector v);
vector operator *(transform t, explicit vector v);
vector operator *(explicit point M, explicit vector v);
line operator *(transform t, line l);
line operator *(real x, line l);
line operator *(int x, line l);
line operator *(point M, line l);
circle operator *(real x, explicit circle c);
circle operator *(int x, explicit circle c);
ellipse operator *(transform t, ellipse el);
parabola operator *(transform t, parabola p);
ellipse operator *(transform t, circle c);
hyperbola operator *(transform t, hyperbola h);
conic operator *(transform t, conic co);
ellipse operator *(real x, ellipse el);
abscissa operator *(real x, explicit abscissa a);
abscissa operator *(explicit abscissa a, real x);
arc operator *(transform t, explicit arc a);
arc operator *(real x, explicit arc a);
arc operator *(int x, explicit arc a);
mass operator *(real x, explicit mass M);
mass operator *(int x, explicit mass M);
mass operator *(transform t, mass M);
triangle operator *(transform T, triangle t);
point operator *(inversion i, point P);
circle operator *(inversion i, line l);
circle operator *(inversion i, circle c);
arc operator *(inversion i, segment s);
path operator *(inversion i, triangle t);
point isogonal(side side, point M);
line isogonal(vertex V, point M);
triangle isogonal(triangle t, point M);
point intersectionpoint(line l1, line l2);
path square(pair z1, pair z2);
real epsgeo;
bool degenerate(conic c);
bool degenerate(circle c);
bool degenerate(ellipse el);
point centroid(point A, point B, point C);
point centroid(triangle t);
void markarc(picture pic=<default>, Label L=<default>, int n=<default>, real radius=<default>, real space=<default>, arc a, pen sectorpen=<default>, pen markpen=<default>, marginT margin(path, pen)=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marker marker=<default>);
bool samecoordsys(bool warn=<default>, ... point[] M);
bool samecoordsys(bool warn=<default>, ... bqe[] bqes);
void dot(picture pic=<default>, Label L, explicit point Z, align align=<default>, string format=<default>, pen p=<default>);
real dot(point A, point B);
real dot(point A, explicit pair B);
real dot(explicit pair A, point B);
void dot(picture pic=<default>, Label L, explicit mass M, align align=<default>, string format=<default>, pen p=<default>);
void dot(picture pic=<default>, triangle t, pen p=<default>);
bool isparabola(bqe bqe);
real sharpdegrees(line l1, line l2);
pair operator /(pair p, coordsys R);
point operator /(explicit point P, real x);
point operator /(real x, explicit point P);
vector operator /(explicit vector v, real x);
line operator /(line l, real x);
line operator /(line l, int x);
circle operator /(explicit circle c, real x);
circle operator /(explicit circle c, int x);
ellipse operator /(ellipse el, real x);
abscissa operator /(real x, explicit abscissa a);
abscissa operator /(explicit abscissa a, real x);
abscissa operator /(int x, explicit abscissa a);
arc operator /(explicit arc a, real x);
mass operator /(explicit mass M, real x);
mass operator /(explicit mass M, int x);
void perpendicularmark(picture pic=<default>, point z, explicit pair align, explicit pair dir=<default>, real size=<default>, pen p=<default>, marginT margin(path, pen)=<default>, filltype filltype=<default>);
void perpendicularmark(picture pic=<default>, point z, vector align, vector dir=<default>, real size=<default>, pen p=<default>, marginT margin(path, pen)=<default>, filltype filltype=<default>);
void perpendicularmark(picture pic=<default>, point z, explicit pair align, path g, real size=<default>, pen p=<default>, marginT margin(path, pen)=<default>, filltype filltype=<default>);
void perpendicularmark(picture pic=<default>, point z, vector align, path g, real size=<default>, pen p=<default>, marginT margin(path, pen)=<default>, filltype filltype=<default>);
void perpendicularmark(picture pic=<default>, line l1, line l2, real size=<default>, pen p=<default>, int quarter=<default>, marginT margin(path, pen)=<default>, filltype filltype=<default>);
string defaultmassformat;
restricted int curvilinearsystem;
circle circumcircle(point A, point B, point C);
circle circumcircle(triangle t);
real elle(real phi, real k);
void filldraw(picture pic=<default>, circle c, pen fillpen=<default>, pen drawpen=<default>);
void filldraw(picture pic=<default>, ellipse el, pen fillpen=<default>, pen drawpen=<default>);
void filldraw(picture pic=<default>, triangle t, pen fillpen=<default>, pen drawpen=<default>);
void filldraw(picture pic=<default>, triangle[] ts, pen fillpen=<default>, pen drawpen=<default>);
path operator ecast(segment s);
circle operator ecast(ellipse el);
ellipse operator ecast(conic co);
parabola operator ecast(conic co);
hyperbola operator ecast(conic co);
circle operator ecast(conic c);
real approximate(real t);
real[] approximate(real[] T);
arc arccircle(point A, point M, point B);
arc arccircle(point A, point B, real angle, bool direction=<default>);
restricted int nodesystem;
private transform rotate(explicit pair dir);
transform rotate(explicit vector dir);
transform rotate(explicit point dir);
void lineinversion();
real degrees(explicit point M, coordsys R=<default>, bool warn=<default>);
real degrees(vector v, coordsys R=<default>, bool warn=<default>);
real degrees(line l, coordsys R=<default>);
real degrees(line l1, line l2);
real degrees(arc a);
bqe equation(ellipse el);
bqe equation(parabola p);
bqe equation(hyperbola h);
bqe equation(explicit conic co);
transform yscaleO(real x);
point orthocentercenter(point A, point B, point C);
point orthocentercenter(triangle t);
path NoModifier(path);
transform projection(point A, point B);
transform projection(point A, point B, point C, point D, bool safe=<default>);
transform projection(line l);
transform projection(line l1, line l2, bool safe=<default>);
triangle tangential(triangle t);
side opposite(vertex V);
vertex opposite(side side);
path compassmark(pair O, pair A, real position, real angle=<default>);
transform xscale(real k, point M);
real rf(real x, real y, real z);
mass mass(point M, real m);
mass mass(explicit point P);
mass mass(coordsys R, explicit pair p, real m);
pen addpenline;
pen addpenline(pen p);
line altitude(vertex V);
line altitude(side side);
void drawline(picture pic=<default>, triangle t, pen p=<default>);
real linemargin;
real linemargin();
bool concurrent(... line[] l);
int conicnodesnumber(conic co, real angle1, real angle2, bool dir=<default>);
path polarconicroutine(conic co, real angle1, real angle2, int n, bool direction)(conic co);
circle circle(explicit point C, real r);
circle circle(point A, point B);
circle circle(segment s);
circle circle(point A, point B, point C);
circle circle(triangle t);
circle circle(inversion i);
point incenter(point A, point B, point C);
point incenter(triangle t);
private point ppoint(arc a, real x);
ellipse ellipse(point F1, point F2, real a);
ellipse ellipse(point F1, point F2, point M);
ellipse ellipse(point C, real a, real b, real angle=<default>);
ellipse ellipse(bqe bqe);
ellipse ellipse(point M1, point M2, point M3, point M4, point M5);
restricted path fromCenter(conic co, real angle1, real angle2, int n, bool direction);
point bisectorpoint(side side);
restricted bool byvertices;
int[] tricoef(side side);
real angle(explicit point M, coordsys R=<default>, bool warn=<default>);
real angle(explicit vector v, coordsys R=<default>, bool warn=<default>);
real angle(line l, coordsys R=<default>);
real angle(line l1, line l2);
real angle(arc a);
real[] intersect(path g, explicit pair p, real fuzz=<default>);
real[] intersect(path g, explicit point P, real fuzz=<default>);
bool operator !=(explicit point M, explicit point N);
bool operator !=(line l1, line l2);
triangle extouch(triangle t);
triangle extouch(side side);
bool operator ==(coordsys c1, coordsys c2);
bool operator ==(explicit point M, explicit point N);
bool operator ==(explicit vector u, explicit vector v);
bool operator ==(line l1, line l2);
surface bispline(real[][] z, real[][] p, real[][] q, real[][] r, real[] x, real[] y, bool[][] cond=<default>);
real[][][] bispline(real[][] f, real[] x, real[] y, real[] xsplinetype(real[], real[])=<default>, real[] ysplinetype(real[], real[])=<default>, bool[][] cond=<default>);
bool vperiodic(real[][] a);
bool vperiodic(triple[][] a);
bool uperiodic(real[][] a);
bool uperiodic(triple[][] a);
void labelz3(picture pic=<default>, Label L=<default>, real z, align align=<default>, string format=<default>, pen p=<default>);
void labelz(picture pic=<default>, Label L=<default>, triple v, align align=<default>, string format=<default>, pen p=<default>);
void ztick3(picture pic=<default>, real z, triple dir=<default>, real size=<default>, pen p=<default>);
void ztick3(picture pic=<default>, Label L, real z, triple dir=<default>, string format=<default>, real size=<default>, pen p=<default>);
void axes3(picture pic=<default>, Label xlabel=<default>, Label ylabel=<default>, Label zlabel=<default>, bool extend=<default>, triple min=<default>, triple max=<default>, pen p=<default>, pen py=<default>, pen pz=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, projection P=<default>);
void zlimits(picture pic=<default>, real min=<default>, real max=<default>, bool crop=<default>);
void zaxis3(picture pic=<default>, Label L=<default>, void axis(picture, axisT)=<default>, real zmin=<default>, real zmax=<default>, pen p=<default>, void ticks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, bool above=<default>, projection P=<default>);
void yaxis3(picture pic=<default>, Label L=<default>, void axis(picture, axisT)=<default>, real ymin=<default>, real ymax=<default>, pen p=<default>, void ticks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, bool above=<default>, projection P=<default>);
real ScaleZ(picture pic=<default>, real z);
real[][] ScaleZ(picture pic=<default>, real[][] P);
void xaxis3(picture pic=<default>, Label L=<default>, void axis(picture, axisT)=<default>, real xmin=<default>, real xmax=<default>, pen p=<default>, void ticks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, bool above=<default>, projection P=<default>);
void autoscale3(picture pic=<default>, void axis(picture, axisT));
void xaxis3At(picture pic=<default>, Label L=<default>, void axis(picture, axisT), real xmin=<default>, real xmax=<default>, pen p=<default>, void ticks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, bool above=<default>, bool opposite=<default>, bool opposite2=<default>, bool primary=<default>, projection P=<default>);
private triple defaultdir(triple X, triple Y, triple Z, bool opposite=<default>, projection P);
real ztrans(real[][] t, real z);
void XYZero(picture, axisT)(triple align=<default>, bool extend=<default>);
void XYZero(picture, axisT);
private real[][][] bispline0(real[][] z, real[][] p, real[][] q, real[][] r, real[] x, real[] y, bool[][] cond=<default>);
void XYEquals(picture, axisT)(real x, real y, triple align=<default>, bool extend=<default>);
void XZEquals(picture, axisT)(real x, real z, triple align=<default>, bool extend=<default>);
void YZEquals(picture, axisT)(real y, real z, triple align=<default>, bool extend=<default>);
void OutTicks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, tickvalues modify(tickvalues)=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void OutTicks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, real[] Ticks, real[] ticks=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void OutTicks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P);
void Ticks3(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)(int sign, Label F=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, real[] Ticks=<default>, real[] ticks=<default>, int N=<default>, bool begin=<default>, bool end=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void Ticks3(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)(int sign, Label F=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, tickvalues modify(tickvalues)=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
triple Dir(real)(triple dir);
void XZZero(picture, axisT)(triple align=<default>, bool extend=<default>);
void XZZero(picture, axisT);
void InOutTicks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, tickvalues modify(tickvalues)=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void InOutTicks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, real[] Ticks, real[] ticks=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void InOutTicks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P);
void Bounds(picture, axisT)(int type=<default>, int type2=<default>, triple align=<default>, bool extend=<default>);
void Bounds(picture, axisT);
ticklocate ticklocate(real a, real b, autoscaleT S=<default>, real tickmin=<default>, real tickmax=<default>, real time(real)=<default>, triple dir(real));
real maxlength(triple f(pair z), pair a, pair b, int nu, int nv);
void InTicks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, tickvalues modify(tickvalues)=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void InTicks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, real[] Ticks, real[] ticks=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void InTicks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P);
void labeltick(picture pic, real[][] T, path3 g, ticklocate locate, real val, int sign, real Size, string ticklabel(real), Label F, real norm=<default>);
path3 Circle(triple c, real r, triple normal=<default>, int n=<default>);
void labelx(picture pic=<default>, Label L=<default>, triple v, align align=<default>, string format=<default>, pen p=<default>);
real ytrans(real[][] t, real y);
real xtrans(real[][] t, real x);
void axis(picture pic=<default>, Label L=<default>, path3 g, path3 g2=<default>, pen p=<default>, void ticks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P), ticklocate locate, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, int[] divisor=<default>, bool above=<default>, bool opposite=<default>);
void yaxis3At(picture pic=<default>, Label L=<default>, void axis(picture, axisT), real ymin=<default>, real ymax=<default>, pen p=<default>, void ticks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, bool above=<default>, bool opposite=<default>, bool opposite2=<default>, bool primary=<default>, projection P=<default>);
real ScaleX(picture pic=<default>, real x);
void limits(picture pic=<default>, triple min, triple max);
void Straight(flatguide3)(... void(flatguide3)[]);
void NoTicks3(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)();
void NoTicks3(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P);
void polargraph(flatguide3)(real r(real, real), real theta(real), real phi(real), int n=<default>, void join(flatguide3)(... void(flatguide3)[])=<default>);
void labelaxis(picture pic, real[][] T, Label L, path3 g, ticklocate locate=<default>, int sign=<default>, bool ticklabels=<default>);
void Spline(flatguide3)(... void(flatguide3)[]);
void drawtick(picture pic, real[][] T, path3 g, path3 g2, ticklocate locate, real val, real Size, int sign, pen p, bool extend);
void labely(picture pic=<default>, Label L=<default>, triple v, align align=<default>, string format=<default>, pen p=<default>);
void xtick(picture pic=<default>, triple v, triple dir=<default>, real size=<default>, pen p=<default>);
void xtick(picture pic=<default>, Label L, triple v, triple dir=<default>, string format=<default>, real size=<default>, pen p=<default>);
void ytick(picture pic=<default>, triple v, triple dir=<default>, real size=<default>, pen p=<default>);
void ytick(picture pic=<default>, Label L, triple v, triple dir=<default>, string format=<default>, real size=<default>, pen p=<default>);
path3 Arc(triple c, triple v1, triple v2, triple normal=<default>, bool direction=<default>, int n=<default>);
path3 Arc(triple c, real r, real theta1, real phi1, real theta2, real phi2, triple normal=<default>, bool direction, int n=<default>);
path3 Arc(triple c, real r, real theta1, real phi1, real theta2, real phi2, triple normal=<default>, int n=<default>);
triple polar(real r, real theta, real phi);
void graph(flatguide3)(triple F(real), real, real, int)(void join(flatguide3)(... void(flatguide3)[]));
void(flatguide3)[] graph(triple F(real), real, real, int)(void join(flatguide3)(... void(flatguide3)[]), bool3 cond(real));
void graph(flatguide3)(picture pic=<default>, real x(real), real y(real), real z(real), real a, real b, int n=<default>, void join(flatguide3)(... void(flatguide3)[])=<default>);
void(flatguide3)[] graph(picture pic=<default>, real x(real), real y(real), real z(real), real a, real b, int n=<default>, bool3 cond(real), void join(flatguide3)(... void(flatguide3)[])=<default>);
void graph(flatguide3)(picture pic=<default>, triple v(real), real a, real b, int n=<default>, void join(flatguide3)(... void(flatguide3)[])=<default>);
void(flatguide3)[] graph(picture pic=<default>, triple v(real), real a, real b, int n=<default>, bool3 cond(real), void join(flatguide3)(... void(flatguide3)[])=<default>);
void graph(flatguide3)(picture pic=<default>, triple[] v, void join(flatguide3)(... void(flatguide3)[])=<default>);
void(flatguide3)[] graph(picture pic=<default>, triple[] v, bool3[] cond, void join(flatguide3)(... void(flatguide3)[])=<default>);
void graph(flatguide3)(picture pic=<default>, real[] x, real[] y, real[] z, void join(flatguide3)(... void(flatguide3)[])=<default>);
void(flatguide3)[] graph(picture pic=<default>, real[] x, real[] y, real[] z, bool3[] cond, void join(flatguide3)(... void(flatguide3)[])=<default>);
void graph(flatguide3)(triple F(path, real), path p, int n=<default>, void join(flatguide3)(... void(flatguide3)[])=<default>);
void graph(flatguide3)(triple F(pair), path p, int n=<default>, void join(flatguide3)(... void(flatguide3)[])=<default>);
void graph(flatguide3)(picture pic=<default>, real f(pair), path p, int n=<default>, void join(flatguide3)(... void(flatguide3)[])=<default>);
void graph(flatguide3)(real f(pair), path p, int n=<default>, real T(pair), void join(flatguide3)(... void(flatguide3)[])=<default>);
void tick(picture pic=<default>, triple v, triple dir, real size=<default>, pen p=<default>);
void tick(picture pic=<default>, Label L, real value, triple v, triple dir, string format=<default>, real size=<default>, pen p=<default>);
void labelx3(picture pic=<default>, Label L=<default>, real x, align align=<default>, string format=<default>, pen p=<default>);
void draw(picture pic=<default>, Label[] L=<default>, void(flatguide3)[][] g, pen[] p, light light=<default>, string name=<default>, render render=<default>, interaction interaction=<default>);
void draw(picture pic=<default>, Label[] L=<default>, void(flatguide3)[][] g, pen p=<default>, light light=<default>, string name=<default>, render render=<default>, interaction interaction=<default>);
private void label(picture pic, Label L, triple v, real x, align align, string format, pen p);
triple Scale(picture pic=<default>, triple v);
triple[][] Scale(picture pic=<default>, triple[][] P);
path3[] segment(triple[] v, bool[] cond, void join(flatguide3)(... void(flatguide3)[])=<default>);
void xtick3(picture pic=<default>, real x, triple dir=<default>, real size=<default>, pen p=<default>);
void xtick3(picture pic=<default>, Label L, real x, triple dir=<default>, string format=<default>, real size=<default>, pen p=<default>);
picture vectorfield(path3 vector(pair v), triple f(pair z), pair a, pair b, int nu=<default>, int nv=<default>, bool truesize=<default>, real maxlength=<default>, bool cond(pair z)=<default>, pen p=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, string name=<default>, render render=<default>);
void ztick(picture pic=<default>, triple v, triple dir=<default>, real size=<default>, pen p=<default>);
void ztick(picture pic=<default>, Label L, triple v, triple dir=<default>, string format=<default>, real size=<default>, pen p=<default>);
real[] uniform(real T(real x), real Tinv(real x), real a, real b, int n);
void(flatguide3)[][] lift(real f(real x, real y), guide[][] g, void join(flatguide3)(... void(flatguide3)[])=<default>);
void(flatguide3)[][] lift(real f(pair z), guide[][] g, void join(flatguide3)(... void(flatguide3)[])=<default>);
void YZZero(picture, axisT)(triple align=<default>, bool extend=<default>);
void YZZero(picture, axisT);
void labely3(picture pic=<default>, Label L=<default>, real y, align align=<default>, string format=<default>, pen p=<default>);
void zaxis3At(picture pic=<default>, Label L=<default>, void axis(picture, axisT), real zmin=<default>, real zmax=<default>, pen p=<default>, void ticks(picture, real[][], Label, path3, path3, pen, bool(picture, path3, material, marginT3(path3, pen), light, light), marginT3(path3, pen), ticklocate, int[], bool opposite=<default>, bool primary=<default>, projection P)=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, bool above=<default>, bool opposite=<default>, bool opposite2=<default>, bool primary=<default>, projection P=<default>);
real ScaleY(picture pic=<default>, real y);
void ytick3(picture pic=<default>, real y, triple dir=<default>, real size=<default>, pen p=<default>);
void ytick3(picture pic=<default>, Label L, real y, triple dir=<default>, string format=<default>, real size=<default>, pen p=<default>);
triple ticklabelshift(triple align, pen p=<default>);
triple tickMax3(picture pic);
triple tickMin3(picture pic);
surface surface(picture pic=<default>, triple[][] f, bool[][] cond=<default>);
surface surface(picture pic=<default>, real[][] f, real[] x, real[] y, real[] xsplinetype(real[], real[])=<default>, real[] ysplinetype(real[], real[])=<default>, bool[][] cond=<default>);
surface surface(picture pic=<default>, real[][] f, pair a, pair b, real[] xsplinetype(real[], real[]), real[] ysplinetype(real[], real[])=<default>, bool[][] cond=<default>);
surface surface(picture pic=<default>, real[][] f, pair a, pair b, bool[][] cond=<default>);
surface surface(picture pic=<default>, triple f(pair z), pair a, pair b, int nu=<default>, int nv=<default>, bool cond(pair z)=<default>);
surface surface(picture pic=<default>, triple f(pair z), real[] u, real[] v, real[](real[], real[])[] usplinetype, real[](real[], real[])[] vsplinetype=<default>, bool cond(pair z)=<default>);
surface surface(picture pic=<default>, triple f(pair z), pair a, pair b, int nu=<default>, int nv=<default>, real[](real[], real[])[] usplinetype, real[](real[], real[])[] vsplinetype=<default>, bool cond(pair z)=<default>);
surface surface(picture pic=<default>, real f(pair z), pair a, pair b, int nx=<default>, int ny=<default>, bool cond(pair z)=<default>);
surface surface(picture pic=<default>, real f(pair z), pair a, pair b, int nx=<default>, int ny=<default>, real[] xsplinetype(real[], real[]), real[] ysplinetype(real[], real[])=<default>, bool cond(pair z)=<default>);
path Circle(pair c, real r, int n=<default>);
path Arc(pair c, real r, real angle1, real angle2, bool direction, int n=<default>);
path Arc(pair c, real r, real angle1, real angle2, int n=<default>);
path Arc(pair c, explicit pair z1, explicit pair z2, bool direction=<default>, int n=<default>);
guide polargraph(picture pic=<default>, real r(real), real a, real b, int n=<default>, guide join(... guide[])=<default>);
guide polargraph(picture pic=<default>, real[] r, real[] theta, guide join(... guide[])=<default>);
void checkconditionlength(int x, int y);
guide Hermite(... guide[])(real[] splinetype(real[], real[]));
guide Hermite(... guide[]);
guide Straight(... guide[]);
picture secondaryY(picture primary=<default>, void f(picture));
picture secondaryX(picture primary=<default>, void f(picture));
private string noprimary;
void labely(picture pic=<default>, Label L=<default>, explicit pair z, align align=<default>, string format=<default>, pen p=<default>);
void labely(picture pic=<default>, Label L=<default>, real y, align align=<default>, string format=<default>, pen p=<default>);
void labely(picture pic=<default>, Label L, string format=<default>, explicit pen p=<default>);
void labelx(picture pic=<default>, Label L=<default>, explicit pair z, align align=<default>, string format=<default>, pen p=<default>);
void labelx(picture pic=<default>, Label L=<default>, real x, align align=<default>, string format=<default>, pen p=<default>);
void labelx(picture pic=<default>, Label L, string format=<default>, explicit pen p=<default>);
void ytick(picture pic=<default>, explicit pair z, pair dir=<default>, real size=<default>, pen p=<default>);
void ytick(picture pic=<default>, real y, pair dir=<default>, real size=<default>, pen p=<default>);
void ytick(picture pic=<default>, Label L, explicit pair z, pair dir=<default>, string format=<default>, real size=<default>, pen p=<default>);
void ytick(picture pic=<default>, Label L, real y, pair dir=<default>, string format=<default>, real size=<default>, pen p=<default>);
void xtick(picture pic=<default>, explicit pair z, pair dir=<default>, real size=<default>, pen p=<default>);
void xtick(picture pic=<default>, real x, pair dir=<default>, real size=<default>, pen p=<default>);
void xtick(picture pic=<default>, Label L, explicit pair z, pair dir=<default>, string format=<default>, real size=<default>, pen p=<default>);
void xtick(picture pic=<default>, Label L, real x, pair dir=<default>, string format=<default>, real size=<default>, pen p=<default>);
real ScaleX(picture pic=<default>, real x);
void xaxis(picture pic=<default>, Label L=<default>, void axis(picture, axisT)=<default>, real xmin=<default>, real xmax=<default>, pen p=<default>, void ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, bool above=<default>);
void limits(picture pic=<default>, pair min, pair max, bool crop=<default>);
void crop(picture pic=<default>);
void ylimits(picture pic=<default>, real min=<default>, real max=<default>, bool crop=<default>);
real ytrans(transform t, real y);
real xtrans(transform t, real x);
void YEquals(picture, axisT)(real y, bool extend=<default>);
void LeftRight(picture, axisT)(bool extend=<default>);
void LeftRight(picture, axisT);
void Right(picture, axisT)(bool extend=<default>);
void Right(picture, axisT);
void Left(picture, axisT)(bool extend=<default>);
void Left(picture, axisT);
axisT axis;
void axis(picture pic=<default>, Label L=<default>, path g, path g2=<default>, pen p=<default>, void ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>), ticklocate locate, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, int[] divisor=<default>, bool above=<default>, bool opposite=<default>);
int Both;
int Max;
int Min;
guide graphwithderiv(pair f(real), pair fprime(real), real a, real b, int n=<default>);
pair tickMax(picture pic);
void RightTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, tickvalues modify(tickvalues)=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void RightTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, real[] Ticks, real[] ticks=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void RightTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>);
tickvalues NoZero(tickvalues);
tickvalues OmitTickInterval(tickvalues)(real a, real b);
void Ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(int sign, Label F=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, real[] Ticks=<default>, real[] ticks=<default>, int N=<default>, bool begin=<default>, bool end=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void Ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(int sign, Label F=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, tickvalues modify(tickvalues)=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void Ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, tickvalues modify(tickvalues)=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void Ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, real[] Ticks, real[] ticks=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void Ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>);
tickvalues generateticks(int sign, Label F=<default>, string ticklabel(real)=<default>, int N, int n=<default>, real Step=<default>, real step=<default>, real Size=<default>, real size=<default>, transform T, pair side, path g, real limit, pen p, ticklocate locate, int[] divisor, bool opposite);
string autoformat(string format=<default>, real norm, ... real[] a);
void labelaxis(frame f, transform T, Label L, path g, ticklocate locate=<default>, int sign=<default>, bool ticklabels=<default>);
void axes(picture pic=<default>, Label xlabel=<default>, Label ylabel=<default>, bool extend=<default>, pair min=<default>, pair max=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, bool above=<default>);
pair labeltick(frame d, transform T, path g, ticklocate locate, real val, pair side, int sign, real Size, string ticklabel(real), Label F, real norm=<default>);
void drawtick(frame f, transform T, path g, path g2, ticklocate locate, real val, real Size, int sign, pen p, bool extend);
ticklocate ticklocate(real a, real b, autoscaleT S=<default>, real tickmin=<default>, real tickmax=<default>, real time(real)=<default>, pair dir(real)=<default>);
autoscaleT defaultS;
string LogFormat(real)(int base);
string LogFormat(real);
string DefaultLogFormat(real)(int base);
string DefaultLogFormat(real);
string DefaultFormat(real);
string signedtrailingzero;
string Format(real)(string s=<default>);
bounds autoscale(real Min, real Max, scaleT scale=<default>);
void autoscale(picture pic=<default>, void axis(picture, axisT));
real upscale(real b, real a);
int[] divisors(int a, int b);
scaleT BrokenLog(real a, real b, bool automin=<default>, bool automax=<default>);
scaleT Broken(real a, real b, bool automin=<default>, bool automax=<default>);
string baselinetemplate;
scaleT Logarithmic;
scaleT Log;
scaleT Log(bool automin=<default>, bool automax=<default>);
guide Spline(... guide[]);
void errorbar(picture pic, pair z, pair dp, pair dm, pen p=<default>, real size=<default>);
tickvalues None(tickvalues v);
void XEquals(picture, axisT)(real x, bool extend=<default>);
string conditionlength;
pair polar(real r, real theta);
guide graph(pair f(real), real, real, int)(guide join(... guide[]));
guide[] graph(pair f(real), real, real, int)(guide join(... guide[]), bool3 cond(real));
guide graph(picture pic=<default>, real f(real), real a, real b, int n=<default>, real T(real)=<default>, guide join(... guide[])=<default>);
guide[] graph(picture pic=<default>, real f(real), real a, real b, int n=<default>, real T(real)=<default>, bool3 cond(real), guide join(... guide[])=<default>);
guide graph(picture pic=<default>, real x(real), real y(real), real a, real b, int n=<default>, real T(real)=<default>, guide join(... guide[])=<default>);
guide[] graph(picture pic=<default>, real x(real), real y(real), real a, real b, int n=<default>, real T(real)=<default>, bool3 cond(real), guide join(... guide[])=<default>);
guide graph(picture pic=<default>, pair z(real), real a, real b, int n=<default>, real T(real)=<default>, guide join(... guide[])=<default>);
guide[] graph(picture pic=<default>, pair z(real), real a, real b, int n=<default>, real T(real)=<default>, bool3 cond(real), guide join(... guide[])=<default>);
guide graph(picture pic=<default>, pair[] z, guide join(... guide[])=<default>);
guide[] graph(picture pic=<default>, pair[] z, bool3[] cond, guide join(... guide[])=<default>);
guide graph(picture pic=<default>, real[] x, real[] y, guide join(... guide[])=<default>);
guide[] graph(picture pic=<default>, real[] x, real[] y, bool3[] cond, guide join(... guide[])=<default>);
void XZero(picture, axisT)(bool extend=<default>);
void XZero(picture, axisT);
pair zero(real);
string NoZeroFormat(real);
string trailingzero;
void xlimits(picture pic=<default>, real min=<default>, real max=<default>, bool crop=<default>);
void scale(picture pic=<default>, scaleT x, scaleT y=<default>, scaleT z=<default>);
void scale(picture pic=<default>, bool xautoscale=<default>, bool yautoscale=<default>, bool zautoscale=<default>);
void Bottom(picture, axisT)(bool extend=<default>);
void Bottom(picture, axisT);
picture vectorfield(path vector(real), path g, int n, bool truesize=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>);
picture vectorfield(path vector(pair), pair a, pair b, int nx=<default>, int ny=<default>, bool truesize=<default>, bool cond(pair z)=<default>, pen p=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>);
pair Scale(picture pic=<default>, pair z);
real linear(real)(real S(real)=<default>, real Min, real Max);
path[] segment(pair[] z, bool[] cond, guide join(... guide[])=<default>);
scaleT Linear;
scaleT Linear(bool automin=<default>, bool automax=<default>, real s=<default>, real intercept=<default>);
void NoTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)();
void NoTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>);
bool logaxiscoverage(int N, transform T, path g, ticklocate locate, pair side, int sign, real Size, Label F, string ticklabel(real), real limit, int first, int last);
string OmitFormat(real)(string s=<default>, ... real[] x);
int Value;
void xequals(picture pic=<default>, Label L=<default>, real x, bool extend=<default>, real ymin=<default>, real ymax=<default>, pen p=<default>, void ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, bool above=<default>);
tickvalues OmitTick(tickvalues)(... real[] x);
void yequals(picture pic=<default>, Label L=<default>, real y, bool extend=<default>, real xmin=<default>, real xmax=<default>, pen p=<default>, void ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, bool above=<default>);
void tick(picture pic=<default>, pair z, pair dir, real size=<default>, pen p=<default>);
void tick(picture pic=<default>, Label L, real value, explicit pair z, pair dir, string format=<default>, real size=<default>, pen p=<default>);
void YZero(picture, axisT)(bool extend=<default>);
void YZero(picture, axisT);
void Top(picture, axisT)(bool extend=<default>);
void Top(picture, axisT);
private void label(picture pic, Label L, pair z, real x, align align, string format, pen p);
void yaxis(picture pic=<default>, Label L=<default>, void axis(picture, axisT)=<default>, real ymin=<default>, real ymax=<default>, pen p=<default>, void ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, bool above=<default>, bool autorotate=<default>);
void xaxisAt(picture pic=<default>, Label L=<default>, void axis(picture, axisT), real xmin=<default>, real xmax=<default>, pen p=<default>, void ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, bool above=<default>, bool opposite=<default>);
tickvalues OmitTickIntervals(tickvalues)(real[] a, real[] b);
void yaxisAt(picture pic=<default>, Label L=<default>, void axis(picture, axisT), real ymin=<default>, real ymax=<default>, pen p=<default>, void ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)=<default>, bool arrow(picture, path, pen, marginT(path, pen))=<default>, marginT margin(path, pen)=<default>, bool above=<default>, bool opposite=<default>);
void BottomTop(picture, axisT)(bool extend=<default>);
void BottomTop(picture, axisT);
pair tickMin(picture pic);
scientific scientific(real x);
void LeftTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, tickvalues modify(tickvalues)=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void LeftTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, real[] Ticks, real[] ticks=<default>, real Size=<default>, real size=<default>, bool extend=<default>, pen pTick=<default>, pen ptick=<default>);
void LeftTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>);
Label Break;
tickvalues Break(tickvalues)(real, real);
real zerotickfuzz;
real ScaleY(picture pic=<default>, real y);
bool axiscoverage(int N, transform T, path g, ticklocate locate, real Step, pair side, int sign, real Size, Label F, string ticklabel(real), real norm, real limit);
pair ticklabelshift(pair align, pen p=<default>);
void errorbars(picture pic=<default>, pair[] z, pair[] dp, pair[] dm=<default>, bool[] cond=<default>, pen p=<default>, real size=<default>);
void errorbars(picture pic=<default>, real[] x, real[] y, real[] dpx, real[] dpy, real[] dmx=<default>, real[] dmy=<default>, bool[] cond=<default>, pen p=<default>, real size=<default>);
void errorbars(picture pic=<default>, real[] x, real[] y, real[] dpy, bool[] cond=<default>, pen p=<default>, real size=<default>);
real axiscoverage;
int nmesh;
int nCircle;
restricted bool Crop;
real Ticksize;
real axislabelfactor;
real ticksize;
restricted bool NoCrop;
real epsilon;
int ngraph;
real ylabelwidth;
guide hermite(real[] x, real[] y, real[] splinetype(real[], real[])=<default>);
real[] monotonic(real[] x, real[] y);
real[] clamped(real[], real[])(real slopea, real slopeb);
real[] natural(real[] x, real[] y);
real[] periodic(real[] x, real[] y);
real[] notaknot(real[] x, real[] y);
void checkincreasing(real[] x);
void checklengths(int x, int y, string text=<default>);
string differentlengths;
string morepoints;
restricted real[] Spline(real[] x, real[] y);
restricted real[](real[], real[])[] Spline;
real[] linear(real[] x, real[] y);
void grid3(picture pic=<default>, grid3(picture pic)[][] gridroutine=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, pen pGrid=<default>, pen pgrid=<default>, bool above=<default>);
void grid3(picture pic=<default>, grid3(picture pic)[][] gridroutine, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, pen[] pGrid, pen[] pgrid, bool above=<default>);
grid3(picture pic)[][] XYZgrid(position pos=<default>);
grid3(picture pic)[][] XYZgrid;
grid3(picture pic)[] ZX_ZYgrid(position posa=<default>, position posb=<default>);
grid3(picture pic)[] ZX_ZYgrid;
grid3(picture pic)[] XY_XZgrid(position posa=<default>, position posb=<default>);
grid3(picture pic)[] XY_XZgrid;
grid3(picture pic)[] YZYgrid(position pos=<default>);
grid3(picture pic)[] YZYgrid;
grid3(picture pic)[] ZYZgrid(position pos=<default>);
grid3(picture pic)[] ZYZgrid;
grid3(picture pic)[] XZXgrid(position pos=<default>);
grid3(picture pic)[] XZXgrid;
grid3 ZYgrid(picture pic)(position pos=<default>);
grid3 ZYgrid(picture pic);
grid3 YZgrid(picture pic)(position pos=<default>);
grid3 YZgrid(picture pic);
grid3 ZXgrid(picture pic)(position pos=<default>);
grid3 ZXgrid(picture pic);
grid3 XZgrid(picture pic)(position pos=<default>);
grid3 XZgrid(picture pic);
grid3 XYgrid(picture pic)(position pos=<default>);
grid3 XYgrid(picture pic);
grid3(picture pic)[] XYXgrid(position pos=<default>);
grid3(picture pic)[] XYXgrid;
position bottom;
grid3(picture pic)[] ZXZgrid(position pos=<default>);
grid3(picture pic)[] ZXZgrid;
ticksgridT OutTicks()(Label F=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, real Size=<default>, real size=<default>, pen pTick=<default>, pen ptick=<default>, grid3(picture pic)[][] gridroutine, pen pGrid=<default>, pen pgrid=<default>);
ticksgridT InTicks()(Label F=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, real Size=<default>, real size=<default>, pen pTick=<default>, pen ptick=<default>, grid3(picture pic)[][] gridroutine, pen pGrid=<default>, pen pgrid=<default>);
grid3(picture pic)[] YXYgrid(position pos=<default>);
grid3(picture pic)[] YXYgrid;
triple X(picture pic);
triple YZ(picture pic);
triple Z(picture pic);
ticksgridT InOutTicks()(Label F=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, bool begin=<default>, bool end=<default>, real Size=<default>, real size=<default>, pen pTick=<default>, pen ptick=<default>, grid3(picture pic)[][] gridroutine, pen pGrid=<default>, pen pgrid=<default>);
triple XY(picture pic);
void zaxis3(picture pic=<default>, Label L=<default>, void axis(picture, axisT)=<default>, pen p=<default>, ticksgridT ticks(), bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, bool above=<default>);
triple ZX(picture pic);
void yaxis3(picture pic=<default>, Label L=<default>, void axis(picture, axisT)=<default>, pen p=<default>, ticksgridT ticks(), bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, bool above=<default>);
void xaxis3(picture pic=<default>, Label L=<default>, void axis(picture, axisT)=<default>, pen p=<default>, ticksgridT ticks(), bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, bool above=<default>);
grid3(picture pic)[] YX_YZgrid(position posa=<default>, position posb=<default>);
grid3(picture pic)[] YX_YZgrid;
grid3 YXgrid(picture pic)(position pos=<default>);
grid3 YXgrid(picture pic);
position middle;
grid3(picture pic)[] operator cast(grid3 gridroutine(picture pic));
grid3(picture pic)[][] operator cast(grid3(picture pic)[] gridroutine);
grid3(picture pic)[][] operator cast(grid3 gridroutine(picture pic));
triple Y(picture pic);
position top;
real fspline(real)(real[] x, real[] y, real[] splinetype(real[], real[])=<default>);
real pwhermite(real)(real[] x, real[] y, real[] dy);
horner diffdiv(real[] x, real[] y);
real fhorner(real)(horner sh);
horner hdiffdiv(real[] x, real[] y, real[] dy);
surface labelpath(string s, path3 p, real angle=<default>, triple optional=<default>);
triple nextnormal(triple p, triple q);
private real eps;
triple[] nextframe(path3 p, real reltimestart, triple[] start, real reltimeend, int subdiv=<default>);
triple[] firstframe(path3 p, triple optional=<default>);
string RightJustified;
string LeftJustified;
string Centered;
void labelpath(frame f, Label L, path g, string justify=<default>, pen p=<default>);
void labelpath(picture pic=<default>, Label L, path g, string justify=<default>, pen p=<default>);
void lm_minimize(int m_dat, int n_par, real[] par, void evaluate(real[] par, int m_dat, real[] fvec, lm_data_type data, lm_int_type info), void printout(int n_par, real[] par, int m_dat, real[] fvec, lm_data_type data, int iflag, int iter, int nfev), lm_data_type data, lm_control_type control);
void lm_lmdif(int m, int n, real[] x, real[] fvec, real ftol, real xtol, real gtol, int maxfev, real epsfcn, real[] diag, int mode, real factor, lm_int_type info, lm_int_type nfev, real[] fjac, int[] ipvt, real[] qtf, real[] wa1, real[] wa2, real[] wa3, real[] wa4, void evaluate(real[] par, int m_dat, real[] fvec, lm_data_type data, lm_int_type info), void printout(int n_par, real[] par, int m_dat, real[] fvec, lm_data_type data, int iflag, int iter, int nfev), lm_data_type data);
void lm_print_quiet(int n_par, real[] par, int m_dat, real[] fvec, lm_data_type data, int iflag, int iter, int nfev);
void lm_evaluate_default(real[] par, int m_dat, real[] fvec, lm_data_type data, lm_int_type info);
restricted string[] lm_infmsg;
private real LM_SQRT_DWARF;
private real LM_DWARF;
private void lm_qrsolv(int n, real[] r, int ldr, int[] ipvt, real[] diag, real[] qtb, real[] x, real[] sdiag, real[] wa);
private real LM_USERTOL;
private real LM_SQRT_GIANT;
private real LM_MACHEP;
private real SQR(real x);
private string pad(string str, int count, string pad=<default>);
private string pad(int num, int digits, string pad=<default>);
private string pad(real num, int digits, string pad=<default>);
private real lm_enorm(int n, real[] x, int offset=<default>);
private void lm_lmpar(int n, real[] r, int ldr, int[] ipvt, real[] diag, real[] qtb, real delta, lm_real_type par, real[] x, real[] sdiag, real[] wa1, real[] wa2);
FitControl operator init();
restricted string[] lm_shortmsg;
FitResult fit(real[] xdata, real[] ydata, real[] errors, real function(real[], real), real[] parameters, FitControl control=<default>);
FitResult fit(real[] xdata, real[] ydata, real function(real[], real), real[] parameters, FitControl control=<default>);
FitControl defaultControl;
void lm_print_default(int n_par, real[] par, int m_dat, real[] fvec, lm_data_type data, int iflag, int iter, int nfev);
private void lm_qrfac(int m, int n, real[] a, bool pivot, int[] ipvt, real[] rdiag, real[] acnorm, real[] wa);
marker TildeIntervalMarker(int i=<default>, int n=<default>, real size=<default>, real space=<default>, real angle=<default>, pair offset=<default>, bool rotated=<default>, pen p=<default>, frame uniform=<default>, bool above=<default>);
marker CrossIntervalMarker(int i=<default>, int n=<default>, real size=<default>, real space=<default>, real angle=<default>, pair offset=<default>, bool rotated=<default>, pen p=<default>, frame uniform=<default>, bool above=<default>);
real markanglespace(pen p=<default>);
real markanglespace;
real barmarksizefactor;
real stickmarksizefactor;
frame tildeframe(int n=<default>, real size=<default>, pair space=<default>, real angle=<default>, pair offset=<default>, pen p=<default>);
frame tildeframe;
real tildemarksize(pen p=<default>);
real tildemarksizefactor;
frame stickframe(int n=<default>, real size=<default>, pair space=<default>, real angle=<default>, pair offset=<default>, pen p=<default>);
frame stickframe;
frame circlebarframe(int n=<default>, real barsize=<default>, real radius=<default>, real angle=<default>, pair offset=<default>, pen p=<default>, filltype filltype=<default>, bool above=<default>);
real barmarksize(pen p=<default>);
real markangleradiusfactor;
real stickmarkspace(pen p=<default>);
marker StickIntervalMarker(int i=<default>, int n=<default>, real size=<default>, real space=<default>, real angle=<default>, pair offset=<default>, bool rotated=<default>, pen p=<default>, frame uniform=<default>, bool above=<default>);
void markangle(picture pic=<default>, Label L=<default>, int n=<default>, real radius=<default>, real space=<default>, pair A, pair O, pair B, bool arrow(picture, path, pen, marginT(path, pen))=<default>, pen p=<default>, filltype filltype=<default>, marginT margin(path, pen)=<default>, marker marker=<default>);
marker operator *(transform T, marker m);
real circlemarkradiusfactor;
real stickmarkspacefactor;
real markangleradius(pen p=<default>);
real markangleradius;
frame duplicate(path g, int n=<default>, pair space=<default>, pen p=<default>);
real crossmarksize(pen p=<default>);
real circlemarkradius(pen p=<default>);
real stickmarksize(pen p=<default>);
real markanglespacefactor;
marker CircleBarIntervalMarker(int i=<default>, int n=<default>, real barsize=<default>, real radius=<default>, real angle=<default>, pair offset=<default>, bool rotated=<default>, pen p=<default>, filltype filltype=<default>, bool circleabove=<default>, frame uniform=<default>, bool above=<default>);
frame crossframe(int n=<default>, real size=<default>, pair space=<default>, real angle=<default>, pair offset=<default>, pen p=<default>);
real crossmarksizefactor;
void markinterval(picture pic=<default>, frame f, path g)(int n=<default>, frame f, bool rotated=<default>);
real findroot(real f(real), real a, real b, real tolerance=<default>, real fa=<default>, real fb=<default>);
real[] leastsquares(real[][] A, real[] b, bool warn=<default>);
pair[][] fft(pair[][] a, int sign=<default>);
real[] zero(int n);
real[][] zero(int n, int m);
int[][] segment(bool[] b);
real asec(real x);
bool polygon(path p);
bool increasing(real[] a, bool strict=<default>);
bool lexorder(pair a, pair b);
bool lexorder(triple a, triple b);
real interpolate(real[] x, real[] y, real x0, int i);
real interpolate(real[] x, real[] y, real x0);
triple intersectionpoint(triple n0, triple P0, triple n1, triple P1);
real csc(real x);
real slope(path g, real x, int n=<default>, real fuzz=<default>);
real slope(path g, explicit pair z, int n=<default>, real fuzz=<default>);
bool rectangular(real[][] m);
bool rectangular(pair[][] m);
bool rectangular(triple[][] m);
void drawline(picture pic=<default>, pair P, pair Q, pen p=<default>);
int unique(real[] a, real x);
int unique(string[] a, string x);
real intersect(pair p, pair q, pair z);
real intersect(triple P, triple Q, triple n, triple Z);
real acot(real x);
int quadrant(real degrees);
pair unityroot(int n, int k=<default>);
real sec(real x);
real cot(real x);
real acsc(real x);
real frac(real x);
pair log(explicit pair z);
pair exp(explicit pair z);
picture grid(int Nx, int Ny, pen p=<default>);
real[] partialsum(real[] a);
real[] partialsum(real[] a, real[] dx);
int[] partialsum(int[] a);
int[] partialsum(int[] a, int[] dx);
int[][] segmentlimits(bool[] b);
bool square(real[][] m);
private string nopoint;
real time(path g, real x, int n=<default>, real fuzz=<default>);
real time(path g, explicit pair z, int n=<default>, real fuzz=<default>);
real value(path g, real x, int n=<default>, real fuzz=<default>);
real value(path g, explicit pair z, int n=<default>, real fuzz=<default>);
pair[] quarticroots(real a, real b, real c, real d, real e);
path cutbefore(path p, path q);
path cuttings;
path cutafter(path p, path q);
void draw(picture pic=<default>, obj o, light light=<default>);
obj operator *(real[][] T, obj o);
real[] solveBVP(real[] f(real, real[]), real a, real b=<default>, real h=<default>, int n=<default>, bool dynamic=<default>, real tolmin=<default>, real tolmax=<default>, real dtmin=<default>, real dtmax=<default>, RKTableau tableau, bool verbose=<default>, real[] initial(real[]), real[] discrepancy(real[]), real[] guess, int iterations=<default>);
solution integrate(real y, real c=<default>, real f(real t, real y), real a, real b=<default>, real h=<default>, int n=<default>, bool dynamic=<default>, real tolmin=<default>, real tolmax=<default>, real dtmin=<default>, real dtmax=<default>, RKTableau tableau, bool verbose=<default>);
Solution integrate(real[] y, real[] f(real t, real[] y), real a, real b=<default>, real h=<default>, int n=<default>, bool dynamic=<default>, real tolmin=<default>, real tolmax=<default>, real dtmin=<default>, real dtmax=<default>, RKTableau tableau, bool verbose=<default>);
real error(real error, real initial, real lowOrder, real norm, real diff);
RKTableau RK5DP;
RKTableau RK5F;
RKTableau RK4;
RKTableau E_PC;
RKTableau PC;
RKTableau E_RK2;
RKTableau RK2;
RKTableau RK3BS;
real stepfactor;
RKTableau RK3;
RKTableau Euler;
real phi4(real x);
real[] Coeff;
void expfactors(real x, coefficients a);
real phi3(real x);
void report(real old, real h, real t);
real adjust(real h, real error, real tolmin, real tolmax, RKTableau tableau);
RKTableau E_Euler;
RKTableau E_RK3BS;
RKTableau RK5;
void write(solution S);
void write(Solution S);
real phi2(real x);
real phi1(real x);
real[][] finiteDifferenceJacobian(real[] f(real[]), real[] t, real[] h=<default>);
real[] newton(int iterations=<default>, real[] f(real[]), real[][] jacobian(real[]), real[] t);
pen[] BWRainbow2(int NColors=<default>);
pen[] quantize(pen[] Palette, int n);
private pen[] BWRainbow(int NColors, bool two);
pen[] BWRainbow(int NColors=<default>);
pen[] Wheel(int NColors=<default>);
void PaletteTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(int sign=<default>)(Label format=<default>, string ticklabel(real)=<default>, bool beginlabel=<default>, bool endlabel=<default>, int N=<default>, int n=<default>, real Step=<default>, real step=<default>, pen pTick=<default>, pen ptick=<default>);
void PaletteTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(int sign=<default>);
pen[] palette(real[] f, pen[] palette);
pen[][] palette(real[][] f, pen[] palette);
void palette(picture pic=<default>, Label L=<default>, bounds bounds, pair initial, pair final, void axis(picture, axisT)=<default>, pen[] palette, pen p=<default>, void ticks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(int sign=<default>)=<default>, bool copy=<default>, bool antialias=<default>);
bounds Full(picture pic, real min, real max);
bounds Automatic(picture pic, real min, real max);
bounds Range(picture pic, real min, real max)(bool automin=<default>, real min=<default>, bool automax=<default>, real max=<default>);
pen[] Rainbow(int NColors=<default>);
pen[] Grayscale(int NColors=<default>);
void image(frame f, real[][] data, pair initial, pair final, pen[] palette, bool transpose=<default>, transform t=<default>, bool copy=<default>, bool antialias=<default>);
void image(frame f, pen[][] data, pair initial, pair final, bool transpose=<default>, transform t=<default>, bool copy=<default>, bool antialias=<default>);
bounds image(picture pic=<default>, real[][] f, bounds range(picture pic, real min, real max)=<default>, pair initial, pair final, pen[] palette, int divs=<default>, bool transpose=<default>, bool copy=<default>, bool antialias=<default>);
bounds image(picture pic=<default>, real f(real, real), bounds range(picture pic, real min, real max)=<default>, pair initial, pair final, int nx=<default>, int ny=<default>, pen[] palette, int divs=<default>, bool antialias=<default>);
void image(picture pic=<default>, pen[][] data, pair initial, pair final, bool transpose=<default>, bool copy=<default>, bool antialias=<default>);
void image(picture pic=<default>, pen f(int, int), int width, int height, pair initial, pair final, bool transpose=<default>, bool antialias=<default>);
bounds image(picture pic=<default>, pair[] z, real[] f, bounds range(picture pic, real min, real max)=<default>, pen[] palette);
bounds image(picture pic=<default>, real[] x, real[] y, real[] f, bounds range(picture pic, real min, real max)=<default>, pen[] palette);
pen[] adjust(picture pic, real min, real max, real rmin, real rmax, pen[] palette);
pen[] cmyk(pen[] Palette);
void NoTicks(frame, transform, Label, pair, path, path, pen, bool(picture, path, pen, marginT(path, pen)), marginT(path, pen), ticklocate, int[], bool opposite=<default>)(int sign=<default>);
private transform swap;
private real[] sequencereal;
pen[] Gradient(int NColors=<default>, ... pen[] p);
picture tile(real Hx=<default>, real Hy=<default>, pen p=<default>, filltype filltype=<default>);
frame tiling(string name, picture pic, pair lb=<default>, pair rt=<default>);
picture crosshatch(real H=<default>, pen p=<default>);
picture checker(real Hx=<default>, real Hy=<default>, pen p=<default>);
real hatchepsilon;
picture brick(real Hx=<default>, real Hy=<default>, pen p=<default>);
void add(string name, picture pic, pair lb=<default>, pair rt=<default>);
picture hatch(real H=<default>, pair dir=<default>, pen p=<default>);
void gsave(picture pic=<default>);
void grestore(picture pic=<default>);
pair align;
pen textpen;
rational sum(rational[] a);
string texstring(rational r);
string string(rational r);
rational[] operator -(rational[] r, rational[] s);
rational[] operator -(rational[] r);
int lcm(int m, int n);
int maxDenominator;
bool[] operator <(rational[] r, rational s);
bool[] operator >(rational[] r, rational s);
rational abs(rational r);
bool[] operator >=(rational[] r, rational s);
bool[] operator <=(rational[] r, rational s);
bool rectangular(rational[][] m);
rational[][] rationalidentity(int n);
int gcd(int m, int n);
rational[] operator /(rational[] r, rational[] s);
rational[] operator *(rational[] r, rational[] s);
void write(file fout, string s=<default>, rational r, void suffix(file)=<default>);
void write(string s=<default>, rational r, void suffix(file)=<default>);
void write(file fout=<default>, string s=<default>, rational[] a, void suffix(file)=<default>);
void write(file fout=<default>, string s=<default>, rational[][] a, void suffix(file)=<default>);
bool[] operator ==(rational[] r, rational s);
bool operator ==(rational[] r, rational[] s);
bool operator ==(rational[][] r, rational[][] s);
rational min(rational a, rational b);
rational max(rational a, rational b);
rational max(rational[] a);
rational[] operator +(rational[] r, rational[] s);
void simplexPhase2();
void simplexPhase1(rational[] c, rational[][] A, rational[] b, int[] Bindices);
void simplexTableau(rational[][] E, int[] Bindices, int I=<default>, int J=<default>, int n=<default>);
bool optimizeTableau;
int[] artificialColumn;
void simplexInit(rational[] c, rational[][] A, int[] s=<default>, rational[] b, int count);
void simplexWrite(rational[][] E, int[] Bindices, int, int);
path roundedpath(path A, real R, real S=<default>);
void currentexitfunction();
void bibliographystyle(string name);
void subitem(string s, pen p=<default>);
string asywrite(string s, string preamble=<default>);
void filecode(bool center=<default>, string s, pen p=<default>, real indent=<default>, real skip=<default>, filltype filltype=<default>);
void code(bool center=<default>, string s, pen p=<default>, real indent=<default>, real skip=<default>, filltype filltype=<default>);
void asyinclude(string s, real xsize=<default>, real ysize=<default>);
void indexedfigure(string prefix, int first, int last, string options=<default>, string caption=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, bool step=<default>);
void multifigure(string[] slist, string options=<default>, string caption=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, bool step=<default>);
void display(frame[] f, real margin=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, bool final=<default>);
void display(frame f, real margin=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, bool final=<default>);
void display(string[] s, real margin=<default>, string[] captions=<default>, string caption=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, bool final=<default>);
void display(string s, string caption=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, bool final=<default>);
void skip(real n=<default>);
void vbox(string s, pen p=<default>);
void center(string s, pen p=<default>);
void outline(string s=<default>, pair position=<default>, pair align=<default>, pen p=<default>);
void title(string s, pair position=<default>, pair align=<default>, pen p=<default>, bool newslide=<default>);
void incrementposition(pair z);
bool checkposition();
void numberpage(pen p=<default>);
void normalvideo();
string texcolor(pen p);
bool empty();
bool havepagenumber;
int page;
int[] lastnode;
int[] firstnode;
pair currentposition;
pen backgroundcolor;
pen steppagenumberpen;
real figureborder;
pen pagenumberpen;
pair pagenumberposition;
string oldbulletcolor;
pair startposition;
void figure(string[] s, string options=<default>, real margin=<default>, string[] captions=<default>, string caption=<default>, string[] url=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, bool final=<default>);
void figure(string s, string options=<default>, string caption=<default>, string url=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, bool final=<default>);
pen foregroundcolor;
void step();
string bulletcolor(string color);
bool landscape;
void erasestep(int erasenode);
bool firststep;
bool reverse;
void item(string s, pen p=<default>, bool step=<default>);
void reversevideo();
void equation(string s, pen p=<default>);
void color(string name, string color);
pen itempen;
pen institutionpen;
void usersetting();
transform tinv;
void setpens(pen red=<default>, pen blue=<default>, pen steppen=<default>);
string[] codefile;
pen authorpen;
int preamblenodes;
void remark(bool center=<default>, string s, pair align=<default>, pen p=<default>, real indent=<default>, bool minipage=<default>, real skip=<default>, filltype filltype=<default>, bool step=<default>);
void exitfunction();
void nextpage(pen p=<default>);
pair titlealign;
pair dateskip;
void asycode(bool center=<default>, string s, string options=<default>, string caption=<default>, string preamble=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, real indent=<default>, real skip=<default>, filltype filltype=<default>, bool newslide=<default>);
real pagemargin;
void asyfigure(string s, string options=<default>, string caption=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, filltype filltype=<default>, bool newslide=<default>);
void titlepage(string title, string author, string institution=<default>, string date=<default>, string url=<default>, bool newslide=<default>);
void bibliography(string name);
pair titlepageposition;
void equations(string s, pen p=<default>);
pen figuremattpen;
pen urlpen;
void asyfilecode(bool center=<default>, string s, string options=<default>, string caption=<default>, pair align=<default>, pen p=<default>, pen figuremattpen=<default>, real indent=<default>, real skip=<default>, filltype filltype=<default>, bool newslide=<default>);
real titleskip;
string cropcode(string s);
pen codepen;
void newslide(bool stepping=<default>);
pair pagenumberalign;
real minipagemargin;
bool stepping;
bool itemstep;
bool allowstepping;
real pagewidth;
real pageheight;
picture background;
void background();
real minipagewidth;
pen titlepagepen;
pen datepen;
real itemskip;
real codeskip;
real aboveequationskip;
pair urlskip;
pen titlepen;
string newbulletcolor;
string bullet;
path curve(pair c, real f(real, real), pair a, pair b);
path curve(pair c, real f(real), pair a, pair b);
real stepfraction;
picture slopefield(real f(real, real), pair a, pair b, int nx=<default>, int ny=<default>, real tickfactor=<default>, pen p=<default>);
picture slopefield(real f(real), pair a, pair b, int nx=<default>, int ny=<default>, pen p=<default>);
surface implicitsurface(real f(triple)=<default>, real ff(real, real, real)=<default>, triple a, triple b, int n=<default>, bool keyword overlapedges=<default>, int keyword nx=<default>, int keyword ny=<default>, int keyword nz=<default>, int keyword maxdepth=<default>, bool keyword usetriangles=<default>);
evaluatedpoint[][][] make3dgrid(triple a, triple b, int nx, int ny, int nz, real f(triple), bool allowzero=<default>);
patch[] maketriangle(path3 external, real f(triple), triple grad(triple), bool allowsubdivide=<default>);
triple normalout(int face);
path3 pathinface(positionedvector v1, positionedvector v2, triple facenorm, triple edge1normout, triple edge2normout);
path3 pathinface(positionedvector v1, positionedvector v2, int face, int edge1face, int edge2face);
triple projecttospan(triple toproject, triple v1, triple v2, real mincoeff=<default>);
real[] projecttospan_findcoeffs(triple toproject, triple v1, triple v2, bool warn=<default>);
path3 pathbetween(positionedvector v1, positionedvector v2);
path3 pathbetween(path3 edgecycle, int vertex1, int vertex2);
int[] makecircle(edge[] edges);
private int YLOW;
private int YHIGH;
private int XLOW;
private int NULL_VERTEX;
patch trianglewithnormals(path3 external, triple n1, triple n2, triple n3);
patch patchwithnormals(path3 external, triple[] u0normals, triple[] u1normals, triple[] v0normals, triple[] v1normals);
patch patchwithnormals(path3 external, triple normalat(triple));
patch[] triangletoquads(path3 external, real f(triple), triple grad(triple), triple a, triple b);
real B23(real t);
evaluatedpoint[][] slice(evaluatedpoint[][] a, int start1, int end1, int start2, int end2);
evaluatedpoint[][][] slice(evaluatedpoint[][][] a, int start1, int end1, int start2, int end2, int start3, int end3);
positionedvector[][] slice(positionedvector[][] a, int start1, int end1, int start2, int end2);
positionedvector[][][] slice(positionedvector[][][] a, int start1, int end1, int start2, int end2, int start3, int end3);
real B03(real t);
bool checkpt(triple testpt, real f(triple), triple grad(triple), triple a, triple b);
real(real)[] bernstein;
bool checkptincube(triple pt, triple a, triple b);
triple nGrad(triple)(real f(triple));
bool check_fpt_zero(triple testpoint, real f(triple), triple grad(triple));
real angledegrees(triple a, triple b);
path3 bisector(path3 edgecycle, int[] savevertices);
private int XHIGH;
private int ZHIGH;
string operator cast(edge e);
string operator cast(edge[] edges);
string operator cast(positionedvector vv);
triple operator cast(evaluatedpoint p);
patch[] quadpatches(path3 edgecycle, positionedvector[] corners, real f(triple), triple grad(triple), triple a, triple b, bool usetriangles);
real B33(real t);
real B13(real t);
private int ZLOW;
bool operator ==(edge a, edge b);
revolution sphere(triple c=<default>, real r, int n=<default>);
path line(path p, path q, real[] t);
pen defaultbackpen;
real[] tangent(path p, path q, bool side);
surface surface(revolution r, int n=<default>, pen color(int i, real j)=<default>);
void draw(picture pic=<default>, revolution r, int m=<default>, int n=<default>, pen frontpen=<default>, pen backpen=<default>, pen longitudinalpen=<default>, pen longitudinalbackpen=<default>, light light=<default>, string name=<default>, render render=<default>, projection P=<default>);
revolution operator *(real[][] t, revolution r);
revolution cone(triple c=<default>, real r, real h, triple axis=<default>, int n=<default>);
path[] cylinder(path3 base, real h, triple axis=<default>, projection P);
revolution cylinder(triple c=<default>, real r, real h, triple axis=<default>);
linefit leastsquares(real[] x, real[] y);
linefit leastsquares(real[] x, real[] y, real[] w);
pair Gaussrandpair();
int bins(real[] data, int max=<default>);
path topbox(pair a, pair b);
path halfbox(pair a, pair b);
int[] frequency(real[] data, real[] bins);
int[] frequency(real[] data, real a, real b, int n);
int[][] frequency(real[] x, real[] y, real[] xbins, real[] ybins);
int[][] frequency(real[] x, real[] y, pair a, pair b, int nx, int ny=<default>);
int[][] frequency(pair[] z, pair a, pair b, int nx, int ny=<default>);
real kurtosisexcess(real[] A);
real kurtosis(real[] A);
real skewness(real[] A);
real rms(real[] A);
real variance(real[] A);
real Gaussrand();
real legendmarkersize;
real stdev(real[] A);
real mean(real[] A);
real Gaussian(real x, real sigma);
real Gaussian(real x);
real variancebiased(real[] A);
void histogram(picture pic=<default>, real[] bins, real[] count, real low=<default>, pen fillpen=<default>, pen drawpen=<default>, bool bars=<default>, Label legend=<default>, real markersize=<default>);
void histogram(picture pic=<default>, real[] data, real a, real b, int n, bool normalize=<default>, real low=<default>, pen fillpen=<default>, pen drawpen=<default>, bool bars=<default>, Label legend=<default>, real markersize=<default>);
Braid apply(Relation r, Braid b, int step, int place);
Relation operator -(Relation r);
Component wye;
Component bm;
Component bp;
pair[] endpoints(guide[] a);
Relation r4a;
real gapfactor;
Relation r4b;
picture tableau(frame[] cards, bool number=<default>);
pair min(pair[] z);
Relation r3;
pair max(pair[] z);
real hwratio;
Component phi;
pen Gray;
pen Brown;
pen OliveGreen;
pen SpringGreen;
pen YellowGreen;
pen LimeGreen;
pen PineGreen;
pen Green;
pen JungleGreen;
pen Aquamarine;
pen SkyBlue;
pen ProcessBlue;
pen Blue;
pen NavyBlue;
pen MidnightBlue;
pen Periwinkle;
pen BlueViolet;
pen Violet;
pen Plum;
pen Purple;
pen Sepia;
pen Black;
pen BlueGreen;
pen Lavender;
pen Cerulean;
pen WildStrawberry;
pen RedOrange;
pen Apricot;
pen RawSienna;
pen Orange;
pen GreenYellow;
pen Red;
pen ForestGreen;
pen BurntOrange;
pen Rhodamine;
pen YellowOrange;
pen CadetBlue;
pen Emerald;
pen Peach;
pen Turquoise;
pen DarkOrchid;
pen RoyalPurple;
pen Dandelion;
pen Orchid;
pen BrickRed;
pen CornflowerBlue;
pen Yellow;
pen Cyan;
pen Bittersweet;
pen White;
pen Maroon;
pen Tan;
pen TealBlue;
pen RoyalBlue;
pen Magenta;
pen Melon;
pen Mulberry;
pen Goldenrod;
pen SeaGreen;
pen CarnationPink;
pen Mahogany;
pen OrangeRed;
pen RubineRed;
pen Salmon;
pen VioletRed;
pen RedViolet;
pen Fuchsia;
pen Thistle;
void currentexitfunction();
frame[] fit3(string prefix=<default>, picture[] pictures, picture all, string format=<default>, bool view=<default>, string options=<default>, string script=<default>, light light=<default>, projection P=<default>);
projection[][] SixViews;
projection[][] ThreeViewsFR;
frame embedder(object embedder(string prefix, string format), string prefix, string format, bool view, light light);
frame embedder(string prefix, frame f, string format, real width, real height, bool view, string options, string script, light light, projection P);
object embed(string prefix=<default>, string label=<default>, string text=<default>, scene S, string format=<default>, bool view=<default>, string options=<default>, string script=<default>, light light=<default>);
object embed(string prefix=<default>, string label=<default>, string text=<default>, picture pic, string format=<default>, real xsize=<default>, real ysize=<default>, bool keepAspect=<default>, bool view=<default>, string options=<default>, string script=<default>, light light=<default>, projection P=<default>);
object embed(string prefix=<default>, string label=<default>, string text=<default>, frame f, string format=<default>, real width=<default>, real height=<default>, bool view=<default>, string options=<default>, string script=<default>, light light=<default>, projection P=<default>);
string embed3D(string prefix, string label=<default>, string text=<default>, frame f, string format=<default>, real width=<default>, real height=<default>, string options=<default>, string script=<default>, light light=<default>, projection P=<default>, real viewplanesize=<default>);
private string Format(real x);
private string Format(triple v, string sep=<default>);
private string Format(real[] c);
private string Format(real[][] t, string sep=<default>);
projection absperspective(triple camera=<default>, triple target=<default>, real roll=<default>, real angle=<default>);
projection absorthographic(triple camera=<default>, triple target=<default>, real roll=<default>);
bool Bar3(picture, path3, material, marginT3(path3, pen), light, light)(real size=<default>, triple dir=<default>);
bool Bar3(picture, path3, material, marginT3(path3, pen), light, light);
bool BeginBar3(picture, path3, material, marginT3(path3, pen), light, light)(real size=<default>, triple dir=<default>);
bool BeginBar3(picture, path3, material, marginT3(path3, pen), light, light);
bool EndArcArrow3(picture, path3, material, marginT3(path3, pen), light, light)(arrowhead3 arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>, material arrowheadpen=<default>);
bool EndArcArrow3(picture, path3, material, marginT3(path3, pen), light, light);
bool BeginArcArrow3(picture, path3, material, marginT3(path3, pen), light, light)(arrowhead3 arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>, material arrowheadpen=<default>);
bool BeginArcArrow3(picture, path3, material, marginT3(path3, pen), light, light);
bool BeginArrow3(picture, path3, material, marginT3(path3, pen), light, light)(arrowhead3 arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>, material arrowheadpen=<default>);
bool BeginArrow3(picture, path3, material, marginT3(path3, pen), light, light);
arrowhead3 DefaultHead2(triple normal=<default>);
arrowhead3 DefaultHead2;
arrowhead3 TeXHead3;
arrowhead3 DefaultHead3;
real tubethreshold;
surface tube(triple z0, triple c0, triple c1, triple z1, real w);
rmf[] rmf(path3 g, real[] t, triple perp=<default>);
rmf[] rmf(triple z0, triple c0, triple c1, triple z1, real[] t, triple perp=<default>);
marginT3 DotMargins3(path3, pen);
bool Bars3(picture, path3, material, marginT3(path3, pen), light, light)(real size=<default>, triple dir=<default>);
bool Bars3(picture, path3, material, marginT3(path3, pen), light, light);
marginT3 BeginDotMargin3(path3, pen);
marginT3 PenMargins3(path3, pen);
marginT3 EndPenMargin2(path3, pen);
marginT3 EndPenMargin3(path3, pen);
marginT3 PenMargin2(path3, pen);
marginT3 BeginPenMargin2(path3, pen);
marginT3 Margins3(path3, pen);
marginT3 EndMargin3(path3, pen);
marginT3 DotMargin3(path3, pen)(real begin, real end);
marginT3 DotMargin3(path3, pen);
marginT3 PenMargin3(path3, pen)(real begin, real end);
marginT3 PenMargin3(path3, pen);
marginT3 Margin3(path3, pen)(real begin, real end);
marginT3 Margin3(path3, pen);
marginT3 NoMargin3(path3, pen)();
marginT3 NoMargin3(path3, pen);
pair maxbound(triple[] A, projection P);
pair maxbound(triple[][] A, projection P);
restricted surface unitcylinder;
private patch unitcylinder1;
restricted surface unitfrustum(real ta, real tb);
surface octant1(real transition);
restricted surface octant1;
restricted patch octant1x;
private real[][] i;
private real[][] t3;
private real[][] t1;
real[][] aligntransform(path3[] g, real[][] t=<default>, triple position, triple align, pen p=<default>);
real[][] aligntransform(surface s, real[][] t=<default>, triple position, triple align, pen p=<default>);
bool EndArrow3(picture, path3, material, marginT3(path3, pen), light, light)(arrowhead3 arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>, material arrowheadpen=<default>);
bool EndArrow3(picture, path3, material, marginT3(path3, pen), light, light);
real[][] alignshift(path3[] g, real[][] t=<default>, triple position, triple align);
real[][] alignshift(surface s, real[][] t=<default>, triple position, triple align);
restricted surface unithemisphere;
interaction LabelInteraction();
bool overlap(triple[][] p, triple[][] q, real fuzz=<default>);
triple[][] subpatch(triple[][] P, pair a, pair b);
patch subpatch(patch s, pair a, pair b);
marginT3 BeginMargin3(path3, pen);
triple[][] subpatchbegin(triple[][] P, real u, real v);
triple[][][] vsplit(triple[][] P, real u=<default>);
bool unscaled(real[][] t, triple v, triple w);
path[] regularize(path p, bool checkboundary=<default>);
pair[][] coons(path p);
patch tensor(patch s);
pair[][] tensor(path p, pair[] internal);
restricted surface unitsolidcone;
private real nineth;
string meshname(string name);
bool Arrows3(picture, path3, material, marginT3(path3, pen), light, light)(arrowhead3 arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, material arrowheadpen=<default>);
bool Arrows3(picture, path3, material, marginT3(path3, pen), light, light);
int nslice;
projection[][] ThreeViewsUS;
void addPath(picture pic, path3 g, pen p);
void beginTransform(picture pic=<default>, string geometry=<default>, string color=<default>, real duration);
void endgroup3(picture pic=<default>);
light nolight;
light Headlamp;
private real epsilon;
restricted path3 unitsquare3;
restricted path3 unitcircle3;
private real a;
restricted path3[] unitbox;
path3 randompath3(int n, bool cumulate=<default>, void join(flatguide3)(... void(flatguide3)[])=<default>);
triple[] triples(real[] x, real[] y, real[] z);
restricted surface unitplane;
tensionSpecifier tensionSpecifier(void g(flatguide3), int t);
triple[] controlSpecifier(void g(flatguide3), int t);
triple[] dirSpecifier(void g(flatguide3), int t);
transform transform(triple u, triple v, triple O=<default>, projection P=<default>);
real[][] planeproject(triple n, triple O=<default>, triple dir=<default>);
real[][] planeproject(path3 p, triple dir=<default>);
restricted real[][] XZ;
restricted real[][] XZ(projection P=<default>);
restricted real[][] ZX;
restricted real[][] ZX(projection P=<default>);
restricted real[][] ZY;
restricted real[][] ZY(projection P=<default>);
restricted real[][] YZ;
restricted real[][] YZ(projection P=<default>);
restricted real[][] XY;
restricted real[][] XY(projection P=<default>);
triple normal(path3 p);
triple normal(triple[] p);
path nurb(path3 p, projection P, int ninterpolate=<default>);
path3 solve(flatguide3 g);
path path(path3 p, pair P(triple)=<default>);
private path[] path(Label L, pair z=<default>, projection P);
path3 path3(triple v);
path3 path3(path p, triple plane(pair)=<default>);
path3[] path3(explicit path[] g, triple plane(pair)=<default>);
bool cyclic(void g(flatguide3));
triple ZXplane(pair z);
triple YZplane(pair z);
triple XYplane(pair z);
private real Fuzz;
triple reference(triple[] v, int n, triple d0, triple d1);
real[] theta(triple[] v, real[] alpha, real[] beta, triple dir0, triple dirn, real g0, real gn, triple reference);
void join3(flatguide3)(... void(flatguide3)[])(tensionSpecifier t);
void operator spec(flatguide3)(triple v, int side);
void checkEmpty(int n);
Tension noTension;
projection TopView;
triple coons3(path3 external);
projection BottomView;
projection FrontView;
projection RightView;
projection obliqueY(real angle=<default>);
projection obliqueY;
projection obliqueX(real angle=<default>);
projection obliqueX;
projection oblique(real angle=<default>);
projection oblique;
triple camera(real alpha, real beta);
projection orthographic(triple camera, triple up=<default>, triple target=<default>, real zoom=<default>, pair viewportshift=<default>, bool showtarget=<default>, bool center=<default>);
projection orthographic(real x, real y, real z, triple up=<default>, triple target=<default>, real zoom=<default>, pair viewportshift=<default>, bool showtarget=<default>, bool center=<default>);
real[][] distort(triple v);
real[][] look(triple eye, triple up=<default>, triple target=<default>);
triple perp(triple v);
triple project(triple u, triple v);
pair project(triple v, projection P=<default>);
path project(path3 p, projection P=<default>, int ninterpolate=<default>);
pair[] project(triple[] v, projection P=<default>);
path[] project(explicit path3[] g, projection P=<default>);
Label project(Label L, triple u, triple v, triple O=<default>, projection P=<default>);
real[][] reflect(triple u, triple v, triple w);
triple Z;
triple X;
triple O;
real defaulteyetoview;
int maxangleiterations;
real defaultfresnel0;
real defaultmetallic;
render defaultrender;
restricted surface unitcone;
restricted interaction Embedded;
restricted int PRCsphere;
restricted real Single;
restricted real Zero;
pair minbound(triple[] A, projection P);
pair minbound(triple[][] A, projection P);
real[][] shift(triple v);
real[][] shift(real x, real y, real z);
real[][] shift(real[][] t);
pair xypart(triple v);
real[][] yscale3(real y);
restricted real Medium;
bool None(picture, path3, material, marginT3(path3, pen), light, light);
real[][] intersections(path3 p, patch s, real fuzz=<default>);
real[][] intersections(path3 p, surface s, real fuzz=<default>);
triple arcdir(path3 p, real L);
restricted void nullpath3(flatguide3);
restricted real High;
real[][] scale(triple v, real s);
marginT3 TrueMargin3(path3, pen)(real begin, real end);
triple Y;
restricted interaction Billboard;
path3 interp(path3 a, path3 b, real t);
marginT3 operator +(path3, pen)(marginT3 ma(path3, pen), marginT3 mb(path3, pen));
path3 trim(path3 g, real begin, real end);
picture arrow(arrowhead3 arrowhead=<default>, path3 g, material p=<default>, material arrowheadpen=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>, bool forwards=<default>, marginT3 margin(path3, pen)=<default>, bool center=<default>, light light=<default>, light arrowheadlight=<default>);
void arrow(picture pic=<default>, Label L=<default>, triple b, triple dir, real length=<default>, align align=<default>, pen p=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, light light=<default>, light arrowheadlight=<default>, string name=<default>, render render=<default>);
void arrow(picture pic=<default>, Label L=<default>, triple b, pair dir, real length=<default>, align align=<default>, pen p=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, light light=<default>, light arrowheadlight=<default>, string name=<default>, render render=<default>, projection P=<default>);
path3 operator &(path3 p, cycleToken tok);
void tensorshade(transform t=<default>, frame f, patch s, material m, light light=<default>, projection P);
void operator ::(flatguide3)(... void(flatguide3)[]);
pair dir(triple v, triple dir, projection P);
private triple dir(real theta, triple d0, triple d1, triple reference);
triple dir(path3 p);
triple dir(path3 p, path3 h);
real asin1(real x);
void operator --(flatguide3)(... void(flatguide3)[] g);
triple endpoint(path3 p);
triple max(explicit path3[] p);
triple max(surface s);
pair max(surface s, projection P);
pair max(path3 p, projection P);
pair max(frame f, projection P);
path3 approach(path3 p, int n, real radix=<default>);
int length(void g(flatguide3));
path3 arc(triple c, triple v1, triple v2, triple normal=<default>, bool direction=<default>);
path3 arc(triple c, real r, real theta1, real phi1, real theta2, real phi2, triple normal=<default>, bool direction);
path3 arc(triple c, real r, real theta1, real phi1, real theta2, real phi2, triple normal=<default>);
projection[][] SixViewsFR;
void drawTube(frame f, real[][] t=<default>, material[] m, light light=<default>, render render=<default>)(triple[] g, real w, triple min, triple max);
projection[][] SixViewsUS;
triple[] intersectionpoints(path3 p, path3 q, real fuzz=<default>);
triple[] intersectionpoints(explicit path3[] p, explicit path3[] q, real fuzz=<default>);
triple[] intersectionpoints(path3 p, patch s, real fuzz=<default>);
triple[] intersectionpoints(path3 p, surface s, real fuzz=<default>);
void endTransform(picture pic=<default>);
triple beginpoint(path3 p);
void addStereoViews(picture dest, picture src, bool group=<default>, filltype filltype=<default>, real eyetoview=<default>, bool leftright=<default>, projection P=<default>);
void addStereoViews(picture src, bool group=<default>, filltype filltype=<default>, real eyetoview=<default>, bool leftright=<default>, projection P=<default>);
triple[][] subpatchend(triple[][] P, real u, real v);
triple point(explicit void g(flatguide3), int t);
triple point(patch s, real u, real v);
triple point(frame f, triple dir);
triple point(picture pic=<default>, triple dir, bool user=<default>, projection P=<default>);
void drawTessellation(frame f, surface s, material surfacepen=<default>, pen meshpen=<default>, light light=<default>, light meshlight=<default>, string name=<default>, render render=<default>);
void drawTessellation(picture pic=<default>, surface s, material surfacepen=<default>, pen meshpen=<default>, light light=<default>, light meshlight=<default>, string name=<default>, render render=<default>);
render operator init();
Tension operator init();
void operator init(flatguide3)();
material operator init();
void operator ..(flatguide3)(... void(flatguide3)[] g);
string partname(int i, render render=<default>);
void reverse(flatguide3)(void g(flatguide3));
patch reverse(patch s);
triple size3(picture pic, bool user=<default>, projection P=<default>);
restricted surface unitdisk;
void draw(frame f, path3 g, material p=<default>, light light=<default>, string name=<default>, render render=<default>, projection P=<default>);
void draw(frame f, triple[] v, int[][] vi, triple[] n=<default>, int[][] ni=<default>, material m=<default>, pen[] p=<default>, int[][] pi=<default>, light light=<default>, render render=<default>);
void draw(picture pic=<default>, triple[] v, int[][] vi, triple[] n=<default>, int[][] ni=<default>, material m=<default>, pen[] p=<default>, int[][] pi=<default>, light light=<default>, render render=<default>);
void draw(transform t=<default>, frame f, surface s, int nu=<default>, int nv=<default>, material[] surfacepen, pen[] meshpen=<default>, light light=<default>, light meshlight=<default>, string name=<default>, render render=<default>, projection P=<default>);
void draw(transform t=<default>, frame f, surface s, int nu=<default>, int nv=<default>, material surfacepen=<default>, pen meshpen=<default>, light light=<default>, light meshlight=<default>, string name=<default>, render render=<default>, projection P=<default>);
void draw(picture pic=<default>, surface s, int nu=<default>, int nv=<default>, material[] surfacepen, pen[] meshpen=<default>, light light=<default>, light meshlight=<default>, string name=<default>, render render=<default>);
void draw(picture pic=<default>, surface s, int nu=<default>, int nv=<default>, material surfacepen=<default>, pen meshpen=<default>, light light=<default>, light meshlight=<default>, string name=<default>, render render=<default>);
void draw(picture pic=<default>, surface s, int nu=<default>, int nv=<default>, material[] surfacepen, pen meshpen, light light=<default>, light meshlight=<default>, string name=<default>, render render=<default>);
void draw(picture pic=<default>, triple[] P, real[] knot, real[] weights=<default>, pen p=<default>, string name=<default>, render render=<default>);
void draw(picture pic=<default>, triple[][] P, real[] uknot, real[] vknot, real[][] weights=<default>, material m=<default>, pen[] colors=<default>, light light=<default>, string name=<default>, render render=<default>);
void draw(picture pic=<default>, Label L=<default>, path3 g, align align=<default>, material p=<default>, marginT3 margin(path3, pen)=<default>, light light=<default>, string name=<default>, render render=<default>);
void draw(frame f, explicit path3[] g, material p=<default>, light light=<default>, string name=<default>, render render=<default>, projection P=<default>);
void draw(picture pic=<default>, explicit path3[] g, material p=<default>, marginT3 margin(path3, pen)=<default>, light light=<default>, string name=<default>, render render=<default>);
void draw(picture pic=<default>, Label L=<default>, path3 g, align align=<default>, material p=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light), bool bar(picture, path3, material, marginT3(path3, pen), light, light)=<default>, marginT3 margin(path3, pen)=<default>, light light=<default>, light arrowheadlight=<default>, string name=<default>, render render=<default>);
void draw(frame f, path3 g, material p=<default>, bool arrow(picture, path3, material, marginT3(path3, pen), light, light), light light=<default>, light arrowheadlight=<default>, string name=<default>, render render=<default>, projection P=<default>);
real[][] align(triple u);
Label align(Label L, triple dir);
path3[] align(path3[] g, real[][] t=<default>, triple position, triple align, pen p=<default>);
surface align(surface s, real[][] t=<default>, triple position, triple align, pen p=<default>);
projection[][] ThreeViews;
triple midpoint(path3 p);
projection obliqueZ(real angle=<default>);
projection obliqueZ;
void label(frame f, Label L, triple position, align align=<default>, pen p=<default>, light light=<default>, string name=<default>, render render=<default>, interaction interaction=<default>, projection P=<default>);
void label(picture pic=<default>, Label L, triple position, align align=<default>, pen p=<default>, light light=<default>, string name=<default>, render render=<default>, interaction interaction=<default>);
void label(picture pic=<default>, Label L, path3 g, align align=<default>, pen p=<default>, light light=<default>, string name=<default>, interaction interaction=<default>);
path3[] operator ^^(path3 p, path3 q);
path3[] operator ^^(path3 p, explicit path3[] q);
path3[] operator ^^(explicit path3[] p, path3 q);
path3[] operator ^^(explicit path3[] p, explicit path3[] q);
triple relpoint(path3 p, real l);
void add2(picture pic, arrowhead3 arrowhead, real size, real angle, filltype filltype, material arrowheadpen, path3 g, material p, marginT3 margin(path3, pen), light light, light arrowheadlight);
bool EndBar3(picture, path3, material, marginT3(path3, pen), light, light)(real size=<default>, triple dir=<default>);
bool EndBar3(picture, path3, material, marginT3(path3, pen), light, light);
material material(material m, light light, bool colors=<default>);
arrowhead3 HookHead3(real dir=<default>, real barb=<default>);
arrowhead3 HookHead3;
restricted surface unitsphere;
pen color(triple normal, material m, light light, real[][] T=<default>);
triple reldir(path3 p, real l);
triple min3(picture pic, projection P=<default>);
private triple cross(triple d0, triple d1, triple reference);
void write(file file, control c);
void write(file file, Tension t);
void write(file file, dir d);
void write(file file, string s=<default>, explicit flatguide3 x, void suffix(file)=<default>);
void write(string s=<default>, flatguide3 x, void suffix(file)=<default>);
void write(file file, string s=<default>, explicit path3 x, void suffix(file)=<default>);
void write(string s=<default>, explicit path3 x, void suffix(file)=<default>);
void write(file file, string s=<default>, explicit path3[] x, void suffix(file)=<default>);
void write(string s=<default>, explicit path3[] x, void suffix(file)=<default>);
void write(file file, string s=<default>, explicit void(flatguide3)[] x, void suffix(file)=<default>);
void write(string s=<default>, explicit void(flatguide3)[] x, void suffix(file)=<default>);
void write(file file, string s=<default>, material x, void suffix(file)=<default>);
void write(string s=<default>, material x, void suffix(file)=<default>);
triple min(explicit path3[] p);
triple min(surface s);
pair min(surface s, projection P);
pair min(path3 p, projection P);
pair min(frame f, projection P);
material emissive(material m, bool colors=<default>);
bool MidArrow3(picture, path3, material, marginT3(path3, pen), light, light)(arrowhead3 arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, material arrowheadpen=<default>);
bool MidArrow3(picture, path3, material, marginT3(path3, pen), light, light);
void operator cast(flatguide3)(triple v);
void operator cast(flatguide3)(cycleToken);
void operator cast(flatguide3)(tensionSpecifier t);
void operator cast(flatguide3)(curlSpecifier spec);
flatguide3 operator cast(void g(flatguide3));
flatguide3[] operator cast(void(flatguide3)[] g);
void operator cast(flatguide3)(path3 p);
path3 operator cast(void g(flatguide3));
path3 operator cast(triple v);
void(flatguide3)[] operator cast(triple[] v);
path3[] operator cast(triple[] v);
path3[] operator cast(void(flatguide3)[] g);
void(flatguide3)[] operator cast(path3[] g);
path3[] operator cast(path3 p);
path3[] operator cast(void g(flatguide3));
material operator cast(pen p);
material[] operator cast(pen[] p);
light operator cast(triple v);
surface operator cast(surface[] s);
restricted pen[] nullpens;
triple max3(picture pic, projection P=<default>);
void draw3D(frame f, patch s, material m, light light=<default>, render render=<default>, bool primitive=<default>);
triple arcpoint(path3 p, real L);
control nocontrol;
void add(picture pic=<default>, void d(picture, real[][]), bool exact=<default>);
void add(picture pic, arrowhead3 arrowhead, real size, real angle, filltype filltype, position position, material arrowheadpen, path3 g, material p, bool forwards=<default>, marginT3 margin(path3, pen), bool center=<default>, light light, light arrowheadlight);
void add(picture dest, picture src, triple position, bool group=<default>, bool above=<default>);
void add(picture src, triple position, bool group=<default>, bool above=<default>);
void add(picture dest=<default>, object src, pair position=<default>, pair align=<default>, bool group=<default>, filltype filltype=<default>, bool above=<default>);
void add(picture dest=<default>, frame src, triple position);
projection operator *(real[][] t, projection P);
control operator *(real[][] t, control c);
dir operator *(real[][] t, dir d);
path3[] operator *(real[][] t, explicit path3[] p);
triple[] operator *(real[][] t, triple[] v);
triple[][] operator *(real[][] t, triple[][] v);
light operator *(real[][] t, light light);
patch operator *(real[][] t, patch s);
surface operator *(real[][] t, surface s);
triple intersectionpoint(path3 p, path3 q, real fuzz=<default>);
triple invert(pair z, triple normal, triple point, projection P=<default>);
triple invert(pair z, projection P=<default>);
triple invert(pair dir, triple v, projection P=<default>);
path3 invert(path p, triple normal, triple point, projection P=<default>);
path3 invert(path p, triple point, projection P=<default>);
path3 invert(path p, projection P=<default>);
bool Arrow3(picture, path3, material, marginT3(path3, pen), light, light)(arrowhead3 arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>, material arrowheadpen=<default>);
bool Arrow3(picture, path3, material, marginT3(path3, pen), light, light);
restricted int NURBSsphere;
triple[][] degenerate(triple[][] P);
private triple[] split(triple z0, triple c0, triple c1, triple z1, real t=<default>);
triple[][][][] split(triple[][] P, real u=<default>, real v=<default>);
real defaultshininess;
path3 arrowbase(path3 r, triple y, real t, real size);
pair viewportmargin(pair lambda);
real[][] transform3(triple u, triple v, triple w=<default>);
real[][] transform3(projection P=<default>);
void dot(frame f, triple v, material p=<default>, light light=<default>, string name=<default>, render render=<default>, projection P=<default>);
void dot(frame f, triple[] v, material p=<default>, light light=<default>, string name=<default>, render render=<default>, projection P=<default>);
void dot(frame f, path3 g, material p=<default>, light light=<default>, string name=<default>, render render=<default>, projection P=<default>);
void dot(frame f, path3[] g, material p=<default>, light light=<default>, string name=<default>, render render=<default>, projection P=<default>);
void dot(picture pic=<default>, triple v, material p=<default>, light light=<default>, string name=<default>, render render=<default>);
void dot(picture pic=<default>, triple[] v, material p=<default>, light light=<default>, string name=<default>, render render=<default>);
void dot(picture pic=<default>, explicit path3 g, material p=<default>, light light=<default>, string name=<default>, render render=<default>);
void dot(picture pic=<default>, path3[] g, material p=<default>, light light=<default>, string name=<default>, render render=<default>);
void dot(picture pic=<default>, Label L, triple v, align align=<default>, string format=<default>, material p=<default>, light light=<default>, string name=<default>, render render=<default>);
marginT3 PenMargins2(path3, pen);
bool MidArcArrow3(picture, path3, material, marginT3(path3, pen), light, light)(arrowhead3 arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, material arrowheadpen=<default>);
bool MidArcArrow3(picture, path3, material, marginT3(path3, pen), light, light);
triple[][] operator /(triple[][] a, real[][] b);
real reltime(path3 p, real l);
void bar(picture pic, triple a, triple d, triple perp=<default>, material p=<default>, light light=<default>);
picture bar(triple a, triple dir, triple perp=<default>, material p=<default>);
arrowhead3 HookHead2(real dir=<default>, real barb=<default>, triple normal=<default>);
arrowhead3 HookHead2;
projection BackView;
private string format(triple v, string sep=<default>);
projection perspective(triple camera, triple up=<default>, triple target=<default>, real zoom=<default>, real angle=<default>, pair viewportshift=<default>, bool showtarget=<default>, bool autoadjust=<default>, bool center=<default>);
projection perspective(real x, real y, real z, triple up=<default>, triple target=<default>, real zoom=<default>, real angle=<default>, pair viewportshift=<default>, bool showtarget=<default>, bool autoadjust=<default>, bool center=<default>);
projection perspective(string s);
pen operator ecast(material m);
real acos1(real x);
void exitfunction();
real[][] xscale3(real x);
marginT3 BeginPenMargin3(path3, pen);
real[][] rotate(real angle, triple v);
real[][] rotate(real angle, triple u, triple v);
real[][] zscale3(real z);
void operator controls(flatguide3)(triple post, triple pre);
void operator controls(flatguide3)(triple v);
path3 plane(triple u, triple v, triple O=<default>);
void drawarrow(picture pic, arrowhead3 arrowhead=<default>, path3 g, material p=<default>, material arrowheadpen=<default>, real size=<default>, real angle=<default>, position position=<default>, filltype filltype=<default>, bool forwards=<default>, marginT3 margin(path3, pen)=<default>, bool center=<default>, light light=<default>, light arrowheadlight=<default>, projection P=<default>);
void operator ---(flatguide3)(... void(flatguide3)[]);
bool ArcArrow3(picture, path3, material, marginT3(path3, pen), light, light)(arrowhead3 arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, position position=<default>, material arrowheadpen=<default>);
bool ArcArrow3(picture, path3, material, marginT3(path3, pen), light, light);
triple truepoint(picture pic=<default>, triple dir, bool user=<default>, projection P=<default>);
real angleprecision;
restricted real Low;
bool Blank(picture, path3, material, marginT3(path3, pen), light, light);
bool ArcArrows3(picture, path3, material, marginT3(path3, pen), light, light)(arrowhead3 arrowhead=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, material arrowheadpen=<default>);
bool ArcArrows3(picture, path3, material, marginT3(path3, pen), light, light);
void drawarrow2(picture pic, arrowhead3 arrowhead=<default>, path3 g, material p=<default>, material arrowheadpen=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, marginT3 margin(path3, pen)=<default>, light light=<default>, light arrowheadlight=<default>, projection P=<default>);
restricted patch unitfrustum1(real ta, real tb);
projection projection();
surface extrude(path3 p, path3 q);
surface extrude(path3 p, triple axis=<default>);
surface extrude(path p, triple plane(pair)=<default>, triple axis=<default>);
surface extrude(explicit path[] p, triple axis=<default>);
surface extrude(Label L, triple axis=<default>);
path3[] box(triple v1, triple v2);
void unitcylinderDraw(frame f, real[][] t=<default>, material[] m, light light=<default>, render render=<default>)(bool core);
int adjustedIndex(int i, int n, bool cycles);
int computeNormals(triple[] v, int[][] vi, triple[] n, int[][] ni);
restricted real[][] YX;
restricted real[][] YX(projection P=<default>);
marginT3 EndDotMargin3(path3, pen);
light White;
void addArrow(picture pic, arrowhead3 arrowhead, path3 g, pen p, real size, real angle, filltype filltype, real position);
real relative(Label L, path3 g);
real[] curlSpecifier(void g(flatguide3), int t);
void addViews(picture dest, picture src, projection[][] views=<default>, bool group=<default>, filltype filltype=<default>);
void addViews(picture src, projection[][] views=<default>, bool group=<default>, filltype filltype=<default>);
void aim(flatguide3 g, int N);
void aim(flatguide3 g, int i, int n);
path3 circle(triple c, real r, triple normal=<default>);
restricted surface unitcube;
surface cone(path3 base, triple vertex);
int size(void g(flatguide3));
string defaultembed3Doptions;
real camerafactor;
real[][] bend(path3 g, real t);
triple bend(triple p, path3 g, real scale);
void bend(surface s, path3 g, real L);
projection LeftView;
picture arrow2(arrowhead3 arrowhead=<default>, path3 g, material p=<default>, material arrowheadpen=<default>, real size=<default>, real angle=<default>, filltype filltype=<default>, marginT3 margin(path3, pen)=<default>, light light=<default>, light arrowheadlight=<default>);
triple[][][] hsplit(triple[][] P, real v=<default>);
restricted surface nullsurface;
light Viewport;
private real[][] t2;
private real position(position position, real size, path3 g, bool center);
private real angle(triple d0, triple d1, triple reference);
real[] intersect(path3 p, patch s, real fuzz=<default>);
real[] intersect(path3 p, surface s, real fuzz=<default>);
void pixel(picture pic=<default>, triple v, pen p=<default>, real width=<default>);
void _draw(frame f, path3 g, triple center=<default>, material m, light light=<default>, interaction interaction=<default>);
private real[][] flip(real[][] t, triple X, triple Y, triple Z, projection P);
arrowhead3 TeXHead2(triple normal=<default>);
arrowhead3 TeXHead2;
bool operator ==(material m, material n);
triple rectify(triple dir);
string defaultembed3Dscript;
surface surface(Label L, triple position=<default>, bool bbox=<default>);
surface surface(Label L, surface s, real uoffset, real voffset, real height=<default>, bool bottom=<default>, bool top=<default>);
void begingroup3(frame f, string name=<default>, render render=<default>);
void begingroup3(picture pic=<default>, string name=<default>, render render=<default>);
int lookup(tree t, int key);
bool contains(tree t, int key);
tree newtree();
tree add(tree t, int key, int value);
void write(file out=<default>, tree t);
real trembleFrequency;
real trembleRandom;
real trembleAngle;
real magneticRadius;
real trembleFuzz();
restricted int coloredNodes;
path3 roundedpath(path3 A, real r);
surface tube(path3 g, coloredpath section, transform T(real)=<default>, real corner=<default>, real relstep=<default>);
restricted int coloredSegments;
coloredpath operator cast(path p);
coloredpath operator cast(guide p);
private surface surface(rmf[] R, real[] t, coloredpath cp, transform T(real), bool cyclic);
real degrees(rmf a, rmf b);
real[] sample(path3 g, real r, real relstep=<default>);
real tubegranularity;
void render(path3 s, real r, void f(path3, real));
void importv3d(string name);
real[][] Align(real polar, real azimuth);
v3dheadertypes v3dheadertypes;
v3dtypes v3dtypes;
string VERSION;
pen YellowGreen;
pen WhiteSmoke;
pen Violet;
pen Tomato;
pen SteelBlue;
pen SpringGreen;
pen Snow;
pen SkyBlue;
pen Silver;
pen Seashell;
pen SandyBrown;
pen Salmon;
pen SaddleBrown;
pen RosyBrown;
pen Purple;
pen Plum;
pen Pink;
pen PeachPuff;
pen PapayaWhip;
pen PaleVioletRed;
pen PaleTurquoise;
pen PaleGoldenrod;
pen OrangeRed;
pen Orange;
pen Olive;
pen OldLace;
pen NavajoWhite;
pen Moccasin;
pen MintCream;
pen MidnightBlue;
pen MediumTurquoise;
pen MediumSpringGreen;
pen MediumSlateBlue;
pen MediumPurple;
pen LimeGreen;
pen LightSlateGray;
pen LightSkyBlue;
pen LightSalmon;
pen LightGoldenrodYellow;
pen LightCyan;
pen LightCoral;
pen LightBlue;
pen LemonChiffon;
pen LavenderBlush;
pen Lavender;
pen Khaki;
pen IndianRed;
pen HotPink;
pen GreenYellow;
pen Green;
pen Gray;
pen Goldenrod;
pen Gold;
pen GhostWhite;
pen Gainsboro;
pen Fuchsia;
pen FloralWhite;
pen DodgerBlue;
pen DeepSkyBlue;
pen DarkViolet;
pen DarkSlateGray;
pen DarkSlateBlue;
pen DarkSeaGreen;
pen DarkSalmon;
pen DarkOrchid;
pen PowderBlue;
pen Brown;
pen DarkOrange;
pen FireBrick;
pen Maroon;
pen Black;
pen DeepPink;
pen LightPink;
pen Wheat;
pen Navy;
pen Linen;
pen Sienna;
pen White;
pen LightGrey;
pen Cyan;
pen DimGray;
pen LightSeaGreen;
pen Peru;
pen Ivory;
pen BlueViolet;
pen Turquoise;
pen Teal;
pen DarkCyan;
pen AntiqueWhite;
pen ForestGreen;
pen Coral;
pen LightYellow;
pen LawnGreen;
pen AliceBlue;
pen Lime;
pen SlateGray;
pen Cornsilk;
pen SlateBlue;
pen CadetBlue;
pen Red;
pen Azure;
pen LightSteelBlue;
pen MediumAquamarine;
pen DarkGray;
pen MediumBlue;
pen DarkRed;
pen Crimson;
pen MediumOrchid;
pen LightGreen;
pen Blue;
pen MediumSeaGreen;
pen Orchid;
pen PaleGreen;
pen CornflowerBlue;
pen Yellow;
pen Chocolate;
pen Indigo;
pen Tan;
pen Thistle;
pen MediumVioletRed;
pen DarkBlue;
pen OliveDrab;
pen Magenta;
pen MistyRose;
pen Honeydew;
pen Chartreuse;
pen RoyalBlue;
pen SeaGreen;
pen DarkTurquoise;
pen rgbint(int r, int g, int b);
pen Aqua;
pen Aquamarine;
pen Beige;
pen Bisque;
pen BlanchedAlmond;
pen BurlyWood;
pen DarkGoldenrod;
pen DarkGreen;
pen DarkKhaki;
pen DarkMagenta;
pen DarkOliveGreen;
